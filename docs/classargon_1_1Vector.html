<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Argon: argon::Vector&lt; VectorType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Argon<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classargon_1_1Vector.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classargon_1_1Vector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">argon::Vector&lt; VectorType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents a SIMD vector with various operations.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="argon_2vector_8hpp_source.html">vector.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for argon::Vector&lt; VectorType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classargon_1_1Vector__inherit__graph.png" border="0" usemap="#aargon_1_1Vector_3_01VectorType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aargon_1_1Vector_3_01VectorType_01_4_inherit__map" id="aargon_1_1Vector_3_01VectorType_01_4_inherit__map">
<area shape="rect" title="Represents a SIMD vector with various operations." alt="" coords="167,5,377,31"/>
<area shape="rect" href="classArgon.html" title=" " alt="" coords="5,79,165,104"/>
<area shape="poly" title=" " alt="" coords="230,38,117,81,115,76,229,33"/>
<area shape="rect" href="classArgon.html" title=" " alt="" coords="190,79,354,104"/>
<area shape="poly" title=" " alt="" coords="275,44,275,79,269,79,269,44"/>
<area shape="rect" href="classArgon.html" title=" " alt="" coords="379,79,549,104"/>
<area shape="poly" title=" " alt="" coords="317,33,434,76,432,81,315,38"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a42b8f34739c804799a601bdeabedc7ec" id="r_a42b8f34739c804799a601bdeabedc7ec"><td class="memTemplParams" colspan="2"><a id="a42b8f34739c804799a601bdeabedc7ec" name="a42b8f34739c804799a601bdeabedc7ec"></a>
template&lt;size_t LaneIndex&gt; </td></tr>
<tr class="memitem:a42b8f34739c804799a601bdeabedc7ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>const_lane_type</b> = <a class="el" href="classargon_1_1ConstLane.html">ConstLane</a>&lt;LaneIndex, VectorType&gt;</td></tr>
<tr class="memdesc:a42b8f34739c804799a601bdeabedc7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a single lane of the SIMD vector. <br /></td></tr>
<tr class="separator:a42b8f34739c804799a601bdeabedc7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dd715936783524ec28dc59365db01f" id="r_a03dd715936783524ec28dc59365db01f"><td class="memItemLeft" align="right" valign="top"><a id="a03dd715936783524ec28dc59365db01f" name="a03dd715936783524ec28dc59365db01f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>lane_type</b> = <a class="el" href="classargon_1_1Lane.html">Lane</a>&lt;VectorType&gt;</td></tr>
<tr class="memdesc:a03dd715936783524ec28dc59365db01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a single lane of the SIMD vector. <br /></td></tr>
<tr class="separator:a03dd715936783524ec28dc59365db01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bd00a35d6eaa0cca199800e44157d9" id="r_ac5bd00a35d6eaa0cca199800e44157d9"><td class="memItemLeft" align="right" valign="top"><a id="ac5bd00a35d6eaa0cca199800e44157d9" name="ac5bd00a35d6eaa0cca199800e44157d9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>scalar_type</b> = simd::Scalar_t&lt;VectorType&gt;</td></tr>
<tr class="memdesc:ac5bd00a35d6eaa0cca199800e44157d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scalar type of the SIMD vector. <br /></td></tr>
<tr class="separator:ac5bd00a35d6eaa0cca199800e44157d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076579834e2a423dbbf5ebfa42348752" id="r_a076579834e2a423dbbf5ebfa42348752"><td class="memItemLeft" align="right" valign="top"><a id="a076579834e2a423dbbf5ebfa42348752" name="a076579834e2a423dbbf5ebfa42348752"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vector_type</b> = VectorType</td></tr>
<tr class="memdesc:a076579834e2a423dbbf5ebfa42348752"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIMD vector type. <br /></td></tr>
<tr class="separator:a076579834e2a423dbbf5ebfa42348752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a415e7e729cc854cae3463e41cc3705" id="r_a9a415e7e729cc854cae3463e41cc3705"><td class="memItemLeft" align="right" valign="top"><a id="a9a415e7e729cc854cae3463e41cc3705" name="a9a415e7e729cc854cae3463e41cc3705"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>argon_type</b> = <a class="el" href="namespaceargon_1_1helpers.html#a78d315330017f0fe0a14cccd2d5b318a">helpers::ArgonFor_t</a>&lt;VectorType&gt;</td></tr>
<tr class="memdesc:a9a415e7e729cc854cae3463e41cc3705"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classArgon.html">Argon</a> type for the SIMD vector. <br /></td></tr>
<tr class="separator:a9a415e7e729cc854cae3463e41cc3705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f641dc73c423f906d60554a58e763f" id="r_a88f641dc73c423f906d60554a58e763f"><td class="memItemLeft" align="right" valign="top"><a id="a88f641dc73c423f906d60554a58e763f" name="a88f641dc73c423f906d60554a58e763f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>predicate_type</b> = Bool_t&lt;VectorType&gt;</td></tr>
<tr class="memdesc:a88f641dc73c423f906d60554a58e763f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a boolean SIMD vector. <br /></td></tr>
<tr class="separator:a88f641dc73c423f906d60554a58e763f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb337d1f5ce5ced64b5a234b8ee9ee05" id="r_abb337d1f5ce5ced64b5a234b8ee9ee05"><td class="memItemLeft" align="right" valign="top"><a id="abb337d1f5ce5ced64b5a234b8ee9ee05" name="abb337d1f5ce5ced64b5a234b8ee9ee05"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>argon_bool_type</b> = <a class="el" href="namespaceargon_1_1helpers.html#a78d315330017f0fe0a14cccd2d5b318a">helpers::ArgonFor_t</a>&lt;<a class="el" href="#a88f641dc73c423f906d60554a58e763f">predicate_type</a>&gt;</td></tr>
<tr class="memdesc:abb337d1f5ce5ced64b5a234b8ee9ee05"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classArgon.html">Argon</a> type for the boolean vector. <br /></td></tr>
<tr class="separator:abb337d1f5ce5ced64b5a234b8ee9ee05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae1550d3609d2ebcb11e688f2ed6ba78a" id="r_ae1550d3609d2ebcb11e688f2ed6ba78a"><td class="memItemLeft" align="right" valign="top"><a id="ae1550d3609d2ebcb11e688f2ed6ba78a" name="ae1550d3609d2ebcb11e688f2ed6ba78a"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b> ()=default</td></tr>
<tr class="memdesc:ae1550d3609d2ebcb11e688f2ed6ba78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor for the <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> class. <br /></td></tr>
<tr class="separator:ae1550d3609d2ebcb11e688f2ed6ba78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15940b6d4dd426c701699690ad1e0d6" id="r_af15940b6d4dd426c701699690ad1e0d6"><td class="memItemLeft" align="right" valign="top"><a id="af15940b6d4dd426c701699690ad1e0d6" name="af15940b6d4dd426c701699690ad1e0d6"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b> (<a class="el" href="classargon_1_1Vector.html">Vector</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:af15940b6d4dd426c701699690ad1e0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor for the <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> class. <br /></td></tr>
<tr class="separator:af15940b6d4dd426c701699690ad1e0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105e245c0a5438757ef17600891ebc66" id="r_a105e245c0a5438757ef17600891ebc66"><td class="memItemLeft" align="right" valign="top"><a id="a105e245c0a5438757ef17600891ebc66" name="a105e245c0a5438757ef17600891ebc66"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b> (const <a class="el" href="classargon_1_1Vector.html">Vector</a> &amp;other)=default</td></tr>
<tr class="memdesc:a105e245c0a5438757ef17600891ebc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for the <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> class. <br /></td></tr>
<tr class="separator:a105e245c0a5438757ef17600891ebc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573455a9dd82f26b4df6d158ec74104a" id="r_a573455a9dd82f26b4df6d158ec74104a"><td class="memItemLeft" align="right" valign="top"><a id="a573455a9dd82f26b4df6d158ec74104a" name="a573455a9dd82f26b4df6d158ec74104a"></a>
constexpr <a class="el" href="classargon_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classargon_1_1Vector.html">Vector</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:a573455a9dd82f26b4df6d158ec74104a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator for the <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> class. <br /></td></tr>
<tr class="separator:a573455a9dd82f26b4df6d158ec74104a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38fb1aad4f7ce19d608d5d24101d06f" id="r_ae38fb1aad4f7ce19d608d5d24101d06f"><td class="memItemLeft" align="right" valign="top"><a id="ae38fb1aad4f7ce19d608d5d24101d06f" name="ae38fb1aad4f7ce19d608d5d24101d06f"></a>
constexpr <a class="el" href="classargon_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classargon_1_1Vector.html">Vector</a> &amp;other)=default</td></tr>
<tr class="memdesc:ae38fb1aad4f7ce19d608d5d24101d06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for the <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> class. <br /></td></tr>
<tr class="separator:ae38fb1aad4f7ce19d608d5d24101d06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b817b2f0d97814f2cf418b2a2ceba0" id="r_a04b817b2f0d97814f2cf418b2a2ceba0"><td class="memItemLeft" align="right" valign="top">ace&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04b817b2f0d97814f2cf418b2a2ceba0">Vector</a> (VectorType vector)</td></tr>
<tr class="memdesc:a04b817b2f0d97814f2cf418b2a2ceba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a SIMD vector type.  <br /></td></tr>
<tr class="separator:a04b817b2f0d97814f2cf418b2a2ceba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c822d6e8b568d4c6f6131fbbfd10982" id="r_a6c822d6e8b568d4c6f6131fbbfd10982"><td class="memItemLeft" align="right" valign="top">ace&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c822d6e8b568d4c6f6131fbbfd10982">Vector</a> (<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> scalar)</td></tr>
<tr class="memdesc:a6c822d6e8b568d4c6f6131fbbfd10982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a scalar value.  <br /></td></tr>
<tr class="separator:a6c822d6e8b568d4c6f6131fbbfd10982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4503c9cb6430a57c62888056ae5779c" id="r_af4503c9cb6430a57c62888056ae5779c"><td class="memItemLeft" align="right" valign="top">ace&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4503c9cb6430a57c62888056ae5779c">Vector</a> (<a class="el" href="classargon_1_1Lane.html">argon::Lane</a>&lt; VectorType &gt; lane)</td></tr>
<tr class="memdesc:af4503c9cb6430a57c62888056ae5779c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a <a class="el" href="classargon_1_1Lane.html" title="Represents a single lane of a SIMD vector.">Lane</a> object.  <br /></td></tr>
<tr class="separator:af4503c9cb6430a57c62888056ae5779c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bd8c46fcb61704f5c532bae17bf837" id="r_ad0bd8c46fcb61704f5c532bae17bf837"><td class="memTemplParams" colspan="2">template&lt;size_t LaneIndex&gt; </td></tr>
<tr class="memitem:ad0bd8c46fcb61704f5c532bae17bf837"><td class="memTemplItemLeft" align="right" valign="top">ace&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad0bd8c46fcb61704f5c532bae17bf837">Vector</a> (<a class="el" href="classargon_1_1ConstLane.html">argon::ConstLane</a>&lt; LaneIndex, VectorType &gt; lane)</td></tr>
<tr class="memdesc:ad0bd8c46fcb61704f5c532bae17bf837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a <a class="el" href="classargon_1_1ConstLane.html" title="Represents a single lane of a SIMD vector, where the lane&#39;s index is known at compile time.">ConstLane</a> object.  <br /></td></tr>
<tr class="separator:ad0bd8c46fcb61704f5c532bae17bf837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590d4021bde9f5b30cc8ed2c635a209f" id="r_a590d4021bde9f5b30cc8ed2c635a209f"><td class="memTemplParams" colspan="2"><a id="a590d4021bde9f5b30cc8ed2c635a209f" name="a590d4021bde9f5b30cc8ed2c635a209f"></a>
template&lt;typename... ArgTypes&gt; <br />
requires (sizeof...(ArgTypes) &gt; 1)</td></tr>
<tr class="memitem:a590d4021bde9f5b30cc8ed2c635a209f"><td class="memTemplItemLeft" align="right" valign="top">ace&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Vector</b> (ArgTypes... args)</td></tr>
<tr class="separator:a590d4021bde9f5b30cc8ed2c635a209f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab46337e0f5561e0483f3ee7fe33d96" id="r_aeab46337e0f5561e0483f3ee7fe33d96"><td class="memItemLeft" align="right" valign="top"><a id="aeab46337e0f5561e0483f3ee7fe33d96" name="aeab46337e0f5561e0483f3ee7fe33d96"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> () const</td></tr>
<tr class="memdesc:aeab46337e0f5561e0483f3ee7fe33d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate the SIMD vector and return the result. <br /></td></tr>
<tr class="separator:aeab46337e0f5561e0483f3ee7fe33d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22380fcd7fa584e1b5ae7ea528a356be" id="r_a22380fcd7fa584e1b5ae7ea528a356be"><td class="memItemLeft" align="right" valign="top"><a id="a22380fcd7fa584e1b5ae7ea528a356be" name="a22380fcd7fa584e1b5ae7ea528a356be"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a22380fcd7fa584e1b5ae7ea528a356be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vector and return the result. <br /></td></tr>
<tr class="separator:a22380fcd7fa584e1b5ae7ea528a356be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961eee0a20920422afd39f87bcac4aaa" id="r_a961eee0a20920422afd39f87bcac4aaa"><td class="memItemLeft" align="right" valign="top"><a id="a961eee0a20920422afd39f87bcac4aaa" name="a961eee0a20920422afd39f87bcac4aaa"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a961eee0a20920422afd39f87bcac4aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a vector and return the result. <br /></td></tr>
<tr class="separator:a961eee0a20920422afd39f87bcac4aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa2b24573ce469e5f4d3fe63aea513e" id="r_a9fa2b24573ce469e5f4d3fe63aea513e"><td class="memItemLeft" align="right" valign="top"><a id="a9fa2b24573ce469e5f4d3fe63aea513e" name="a9fa2b24573ce469e5f4d3fe63aea513e"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a9fa2b24573ce469e5f4d3fe63aea513e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector and return the result. <br /></td></tr>
<tr class="separator:a9fa2b24573ce469e5f4d3fe63aea513e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1e2d36dd484d61d4a9d4bcf6626b1b" id="r_a4f1e2d36dd484d61d4a9d4bcf6626b1b"><td class="memItemLeft" align="right" valign="top"><a id="a4f1e2d36dd484d61d4a9d4bcf6626b1b" name="a4f1e2d36dd484d61d4a9d4bcf6626b1b"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a4f1e2d36dd484d61d4a9d4bcf6626b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a vector and return the result. <br /></td></tr>
<tr class="separator:a4f1e2d36dd484d61d4a9d4bcf6626b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8bca3fdb3c3f8ea5128a6c9d85dcd5" id="r_a2e8bca3fdb3c3f8ea5128a6c9d85dcd5"><td class="memItemLeft" align="right" valign="top"><a id="a2e8bca3fdb3c3f8ea5128a6c9d85dcd5" name="a2e8bca3fdb3c3f8ea5128a6c9d85dcd5"></a>
ace <a class="el" href="#abb337d1f5ce5ced64b5a234b8ee9ee05">argon_bool_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a2e8bca3fdb3c3f8ea5128a6c9d85dcd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two vectors for equality. <br /></td></tr>
<tr class="separator:a2e8bca3fdb3c3f8ea5128a6c9d85dcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae466b6dff062ccc37ce93cdfb5b4ee0d" id="r_ae466b6dff062ccc37ce93cdfb5b4ee0d"><td class="memItemLeft" align="right" valign="top"><a id="ae466b6dff062ccc37ce93cdfb5b4ee0d" name="ae466b6dff062ccc37ce93cdfb5b4ee0d"></a>
ace <a class="el" href="#abb337d1f5ce5ced64b5a234b8ee9ee05">argon_bool_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:ae466b6dff062ccc37ce93cdfb5b4ee0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two vectors for inequality. <br /></td></tr>
<tr class="separator:ae466b6dff062ccc37ce93cdfb5b4ee0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0863d8504ce7ddb3edf8196115b9109f" id="r_a0863d8504ce7ddb3edf8196115b9109f"><td class="memItemLeft" align="right" valign="top"><a id="a0863d8504ce7ddb3edf8196115b9109f" name="a0863d8504ce7ddb3edf8196115b9109f"></a>
ace <a class="el" href="#abb337d1f5ce5ced64b5a234b8ee9ee05">argon_bool_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a0863d8504ce7ddb3edf8196115b9109f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two vectors, checking if this vector is less than the other. <br /></td></tr>
<tr class="separator:a0863d8504ce7ddb3edf8196115b9109f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c06a4796802f825c7f613b1e927ab69" id="r_a7c06a4796802f825c7f613b1e927ab69"><td class="memItemLeft" align="right" valign="top"><a id="a7c06a4796802f825c7f613b1e927ab69" name="a7c06a4796802f825c7f613b1e927ab69"></a>
ace <a class="el" href="#abb337d1f5ce5ced64b5a234b8ee9ee05">argon_bool_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a7c06a4796802f825c7f613b1e927ab69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two vectors, checking if this vector is greater than the other. <br /></td></tr>
<tr class="separator:a7c06a4796802f825c7f613b1e927ab69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2e5a315ad9da5fcd22286e41840779" id="r_aab2e5a315ad9da5fcd22286e41840779"><td class="memItemLeft" align="right" valign="top"><a id="aab2e5a315ad9da5fcd22286e41840779" name="aab2e5a315ad9da5fcd22286e41840779"></a>
ace <a class="el" href="#abb337d1f5ce5ced64b5a234b8ee9ee05">argon_bool_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:aab2e5a315ad9da5fcd22286e41840779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two vectors, checking if this vector is less than or equal to the other. <br /></td></tr>
<tr class="separator:aab2e5a315ad9da5fcd22286e41840779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b11a98183b55cfc3916463f33d2e868" id="r_a2b11a98183b55cfc3916463f33d2e868"><td class="memItemLeft" align="right" valign="top"><a id="a2b11a98183b55cfc3916463f33d2e868" name="a2b11a98183b55cfc3916463f33d2e868"></a>
ace <a class="el" href="#abb337d1f5ce5ced64b5a234b8ee9ee05">argon_bool_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a2b11a98183b55cfc3916463f33d2e868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two vectors, checking if this vector is greater than or equal to the other. <br /></td></tr>
<tr class="separator:a2b11a98183b55cfc3916463f33d2e868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3822f6247207678e722e5f449eb1eba7" id="r_a3822f6247207678e722e5f449eb1eba7"><td class="memItemLeft" align="right" valign="top"><a id="a3822f6247207678e722e5f449eb1eba7" name="a3822f6247207678e722e5f449eb1eba7"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator++</b> () const</td></tr>
<tr class="memdesc:a3822f6247207678e722e5f449eb1eba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the vector by 1 and return the result. <br /></td></tr>
<tr class="separator:a3822f6247207678e722e5f449eb1eba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f26c7c5be63bf83ae4909bbb6bc2395" id="r_a1f26c7c5be63bf83ae4909bbb6bc2395"><td class="memItemLeft" align="right" valign="top"><a id="a1f26c7c5be63bf83ae4909bbb6bc2395" name="a1f26c7c5be63bf83ae4909bbb6bc2395"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator--</b> () const</td></tr>
<tr class="memdesc:a1f26c7c5be63bf83ae4909bbb6bc2395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the vector by 1 and return the result. <br /></td></tr>
<tr class="separator:a1f26c7c5be63bf83ae4909bbb6bc2395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bf25e981460042b2c03c7de78d9fa9" id="r_ab2bf25e981460042b2c03c7de78d9fa9"><td class="memItemLeft" align="right" valign="top"><a id="ab2bf25e981460042b2c03c7de78d9fa9" name="ab2bf25e981460042b2c03c7de78d9fa9"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:ab2bf25e981460042b2c03c7de78d9fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise AND two vectors and return the result. <br /></td></tr>
<tr class="separator:ab2bf25e981460042b2c03c7de78d9fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fad39c2d803b886b3aeddfb53724d3" id="r_ac1fad39c2d803b886b3aeddfb53724d3"><td class="memItemLeft" align="right" valign="top"><a id="ac1fad39c2d803b886b3aeddfb53724d3" name="ac1fad39c2d803b886b3aeddfb53724d3"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:ac1fad39c2d803b886b3aeddfb53724d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise OR two vectors and return the result. <br /></td></tr>
<tr class="separator:ac1fad39c2d803b886b3aeddfb53724d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4bd20c3c40801bd450640158397dfe" id="r_a3a4bd20c3c40801bd450640158397dfe"><td class="memItemLeft" align="right" valign="top"><a id="a3a4bd20c3c40801bd450640158397dfe" name="a3a4bd20c3c40801bd450640158397dfe"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator^</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a3a4bd20c3c40801bd450640158397dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise XOR two vectors and return the result. <br /></td></tr>
<tr class="separator:a3a4bd20c3c40801bd450640158397dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd26fad8c2c62b53c010b644c17dd2d5" id="r_acd26fad8c2c62b53c010b644c17dd2d5"><td class="memItemLeft" align="right" valign="top"><a id="acd26fad8c2c62b53c010b644c17dd2d5" name="acd26fad8c2c62b53c010b644c17dd2d5"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator~</b> () const</td></tr>
<tr class="memdesc:acd26fad8c2c62b53c010b644c17dd2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise NOT the vector and return the result. <br /></td></tr>
<tr class="separator:acd26fad8c2c62b53c010b644c17dd2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe775437efecd8707f0035fbcb8c003e" id="r_afe775437efecd8707f0035fbcb8c003e"><td class="memItemLeft" align="right" valign="top"><a id="afe775437efecd8707f0035fbcb8c003e" name="afe775437efecd8707f0035fbcb8c003e"></a>
ace <a class="el" href="classargon_1_1Lane.html">Lane</a>&lt; const VectorType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const size_t i) const</td></tr>
<tr class="memdesc:afe775437efecd8707f0035fbcb8c003e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a lane of the vector by index. <br /></td></tr>
<tr class="separator:afe775437efecd8707f0035fbcb8c003e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc338a3a3f189ca60641a78baea9a0d" id="r_adcc338a3a3f189ca60641a78baea9a0d"><td class="memItemLeft" align="right" valign="top"><a id="adcc338a3a3f189ca60641a78baea9a0d" name="adcc338a3a3f189ca60641a78baea9a0d"></a>
ace <a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const size_t i)</td></tr>
<tr class="memdesc:adcc338a3a3f189ca60641a78baea9a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a lane of the vector by index. <br /></td></tr>
<tr class="separator:adcc338a3a3f189ca60641a78baea9a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff3e0d571d20cdee829f2d023a4b209" id="r_adff3e0d571d20cdee829f2d023a4b209"><td class="memItemLeft" align="right" valign="top"><a id="adff3e0d571d20cdee829f2d023a4b209" name="adff3e0d571d20cdee829f2d023a4b209"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const int i) const</td></tr>
<tr class="memdesc:adff3e0d571d20cdee829f2d023a4b209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the vector to the right by a specified number of bits. <br /></td></tr>
<tr class="separator:adff3e0d571d20cdee829f2d023a4b209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c22d70595aaf24b86bdaf8a7586a609" id="r_a7c22d70595aaf24b86bdaf8a7586a609"><td class="memItemLeft" align="right" valign="top"><a id="a7c22d70595aaf24b86bdaf8a7586a609" name="a7c22d70595aaf24b86bdaf8a7586a609"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const int i) const</td></tr>
<tr class="memdesc:a7c22d70595aaf24b86bdaf8a7586a609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the vector to the left by a specified number of bits. <br /></td></tr>
<tr class="separator:a7c22d70595aaf24b86bdaf8a7586a609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a31c64f4d5a2c75097ea19bf381f8ea" id="r_a1a31c64f4d5a2c75097ea19bf381f8ea"><td class="memItemLeft" align="right" valign="top"><a id="a1a31c64f4d5a2c75097ea19bf381f8ea" name="a1a31c64f4d5a2c75097ea19bf381f8ea"></a>
constexpr VectorType&#160;</td><td class="memItemRight" valign="bottom"><b>vec</b> () const</td></tr>
<tr class="memdesc:a1a31c64f4d5a2c75097ea19bf381f8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying SIMD vector. <br /></td></tr>
<tr class="separator:a1a31c64f4d5a2c75097ea19bf381f8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af35c1c2f74dafa3724c38f2f191481" id="r_a9af35c1c2f74dafa3724c38f2f191481"><td class="memItemLeft" align="right" valign="top"><a id="a9af35c1c2f74dafa3724c38f2f191481" name="a9af35c1c2f74dafa3724c38f2f191481"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>operator VectorType</b> () const</td></tr>
<tr class="memdesc:a9af35c1c2f74dafa3724c38f2f191481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the vector to the underlying SIMD vector type. <br /></td></tr>
<tr class="separator:a9af35c1c2f74dafa3724c38f2f191481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad901839710b6027bfc0b3882d1ada7d3" id="r_ad901839710b6027bfc0b3882d1ada7d3"><td class="memItemLeft" align="right" valign="top">ace std::array&lt; <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>, <a class="el" href="#ad92ce1a195a40c1f752ce0ddc524c9e4">lanes</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad901839710b6027bfc0b3882d1ada7d3">to_array</a> ()</td></tr>
<tr class="memdesc:ad901839710b6027bfc0b3882d1ada7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the vector to an array of scalar values.  <br /></td></tr>
<tr class="separator:ad901839710b6027bfc0b3882d1ada7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c03e6716e222b5d7bca11379c551a48" id="r_a5c03e6716e222b5d7bca11379c551a48"><td class="memItemLeft" align="right" valign="top">ace const <a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c03e6716e222b5d7bca11379c551a48">GetLane</a> (const size_t i) const</td></tr>
<tr class="memdesc:a5c03e6716e222b5d7bca11379c551a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a single lane of the vector by index.  <br /></td></tr>
<tr class="separator:a5c03e6716e222b5d7bca11379c551a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4653730f9c2b236b1bff31e30fd4cd4" id="r_ab4653730f9c2b236b1bff31e30fd4cd4"><td class="memItemLeft" align="right" valign="top"><a id="ab4653730f9c2b236b1bff31e30fd4cd4" name="ab4653730f9c2b236b1bff31e30fd4cd4"></a>
ace <a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetLane</b> (const size_t i)</td></tr>
<tr class="separator:ab4653730f9c2b236b1bff31e30fd4cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37a5488e8811817d2909772b1ff8ca6" id="r_ae37a5488e8811817d2909772b1ff8ca6"><td class="memItemLeft" align="right" valign="top">ace const <a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae37a5488e8811817d2909772b1ff8ca6">GetLane</a> (const int i) const</td></tr>
<tr class="memdesc:ae37a5488e8811817d2909772b1ff8ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a single lane of the vector by index.  <br /></td></tr>
<tr class="separator:ae37a5488e8811817d2909772b1ff8ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850c0671adf8951f137079c42424db43" id="r_a850c0671adf8951f137079c42424db43"><td class="memItemLeft" align="right" valign="top"><a id="a850c0671adf8951f137079c42424db43" name="a850c0671adf8951f137079c42424db43"></a>
ace <a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetLane</b> (const int i)</td></tr>
<tr class="separator:a850c0671adf8951f137079c42424db43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0e82bb381963cb4a43c3c54762484b" id="r_aca0e82bb381963cb4a43c3c54762484b"><td class="memTemplParams" colspan="2">template&lt;size_t LaneIndex&gt; </td></tr>
<tr class="memitem:aca0e82bb381963cb4a43c3c54762484b"><td class="memTemplItemLeft" align="right" valign="top">ace const <a class="el" href="#a42b8f34739c804799a601bdeabedc7ec">const_lane_type</a>&lt; LaneIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca0e82bb381963cb4a43c3c54762484b">GetLane</a> () const</td></tr>
<tr class="memdesc:aca0e82bb381963cb4a43c3c54762484b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a single lane of the vector by index.  <br /></td></tr>
<tr class="separator:aca0e82bb381963cb4a43c3c54762484b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7400b7861d91903f84443a4ae7b694f1" id="r_a7400b7861d91903f84443a4ae7b694f1"><td class="memTemplParams" colspan="2"><a id="a7400b7861d91903f84443a4ae7b694f1" name="a7400b7861d91903f84443a4ae7b694f1"></a>
template&lt;size_t LaneIndex&gt; </td></tr>
<tr class="memitem:a7400b7861d91903f84443a4ae7b694f1"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a42b8f34739c804799a601bdeabedc7ec">const_lane_type</a>&lt; LaneIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetLane</b> ()</td></tr>
<tr class="separator:a7400b7861d91903f84443a4ae7b694f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b544fb855ffe0e00e9ce66d6ddd31d" id="r_aa6b544fb855ffe0e00e9ce66d6ddd31d"><td class="memItemLeft" align="right" valign="top"><a id="aa6b544fb855ffe0e00e9ce66d6ddd31d" name="aa6b544fb855ffe0e00e9ce66d6ddd31d"></a>
ace <a class="el" href="#a42b8f34739c804799a601bdeabedc7ec">const_lane_type</a>&lt; <a class="el" href="#ad92ce1a195a40c1f752ce0ddc524c9e4">lanes</a> - 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LastLane</b> ()</td></tr>
<tr class="memdesc:aa6b544fb855ffe0e00e9ce66d6ddd31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last lane of the vector. <br /></td></tr>
<tr class="separator:aa6b544fb855ffe0e00e9ce66d6ddd31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67afa3ff14121529d8ae26ff64ad646b" id="r_a67afa3ff14121529d8ae26ff64ad646b"><td class="memItemLeft" align="right" valign="top"><a id="a67afa3ff14121529d8ae26ff64ad646b" name="a67afa3ff14121529d8ae26ff64ad646b"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ShiftRight</b> (const int i) const</td></tr>
<tr class="memdesc:a67afa3ff14121529d8ae26ff64ad646b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the vector to the right by a specified number of bits. <br /></td></tr>
<tr class="separator:a67afa3ff14121529d8ae26ff64ad646b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5174f52a764a872b5c4551ffbbcbc3" id="r_a1f5174f52a764a872b5c4551ffbbcbc3"><td class="memItemLeft" align="right" valign="top"><a id="a1f5174f52a764a872b5c4551ffbbcbc3" name="a1f5174f52a764a872b5c4551ffbbcbc3"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ShiftLeft</b> (const int i) const</td></tr>
<tr class="memdesc:a1f5174f52a764a872b5c4551ffbbcbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the vector to the left by a specified number of bits. <br /></td></tr>
<tr class="separator:a1f5174f52a764a872b5c4551ffbbcbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa1d31f4317124025325003c257d50f" id="r_a6fa1d31f4317124025325003c257d50f"><td class="memItemLeft" align="right" valign="top"><a id="a6fa1d31f4317124025325003c257d50f" name="a6fa1d31f4317124025325003c257d50f"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Negate</b> () const</td></tr>
<tr class="memdesc:a6fa1d31f4317124025325003c257d50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise negate the vector and return the result. <br /></td></tr>
<tr class="separator:a6fa1d31f4317124025325003c257d50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01b7082ded41ed06e4eceb745ea387e" id="r_ae01b7082ded41ed06e4eceb745ea387e"><td class="memItemLeft" align="right" valign="top"><a id="ae01b7082ded41ed06e4eceb745ea387e" name="ae01b7082ded41ed06e4eceb745ea387e"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Add</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:ae01b7082ded41ed06e4eceb745ea387e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two vectors. <br /></td></tr>
<tr class="separator:ae01b7082ded41ed06e4eceb745ea387e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cebac6fe57dcbc72385ffa4f27c76c1" id="r_a7cebac6fe57dcbc72385ffa4f27c76c1"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cebac6fe57dcbc72385ffa4f27c76c1">AddHalve</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a7cebac6fe57dcbc72385ffa4f27c76c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two vectors, halving the result.  <br /></td></tr>
<tr class="separator:a7cebac6fe57dcbc72385ffa4f27c76c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5048c4ce50086aa1662e60155ff83e4" id="r_af5048c4ce50086aa1662e60155ff83e4"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5048c4ce50086aa1662e60155ff83e4">AddHalveRound</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:af5048c4ce50086aa1662e60155ff83e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two vectors, halving and rounding the result.  <br /></td></tr>
<tr class="separator:af5048c4ce50086aa1662e60155ff83e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36da1a5e6e183e9ec58773f86a730775" id="r_a36da1a5e6e183e9ec58773f86a730775"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36da1a5e6e183e9ec58773f86a730775">AddSaturate</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a36da1a5e6e183e9ec58773f86a730775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two vectors, saturating the result.  <br /></td></tr>
<tr class="separator:a36da1a5e6e183e9ec58773f86a730775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23b164299323cc619dda55b3797c147" id="r_af23b164299323cc619dda55b3797c147"><td class="memItemLeft" align="right" valign="top"><a id="af23b164299323cc619dda55b3797c147" name="af23b164299323cc619dda55b3797c147"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Subtract</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:af23b164299323cc619dda55b3797c147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two vectors. <br /></td></tr>
<tr class="separator:af23b164299323cc619dda55b3797c147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb396f0fbf479eab31e7ca97a4e88e02" id="r_aeb396f0fbf479eab31e7ca97a4e88e02"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb396f0fbf479eab31e7ca97a4e88e02">SubtractHalve</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:aeb396f0fbf479eab31e7ca97a4e88e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two vectors, halving the result.  <br /></td></tr>
<tr class="separator:aeb396f0fbf479eab31e7ca97a4e88e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67f82f7ac8a10fd748715bf3a99e582" id="r_ab67f82f7ac8a10fd748715bf3a99e582"><td class="memItemLeft" align="right" valign="top"><a id="ab67f82f7ac8a10fd748715bf3a99e582" name="ab67f82f7ac8a10fd748715bf3a99e582"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SubtractSaturate</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:ab67f82f7ac8a10fd748715bf3a99e582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two vectors, saturating the result. <br /></td></tr>
<tr class="separator:ab67f82f7ac8a10fd748715bf3a99e582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bb694741ef42d25f930cb7fce004ac" id="r_aa3bb694741ef42d25f930cb7fce004ac"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3bb694741ef42d25f930cb7fce004ac">SubtractAbs</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:aa3bb694741ef42d25f930cb7fce004ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two vectors, taking the absolute value of the result.  <br /></td></tr>
<tr class="separator:aa3bb694741ef42d25f930cb7fce004ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef58f8dc53b5ce13887f3fcd721d7fda" id="r_aef58f8dc53b5ce13887f3fcd721d7fda"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef58f8dc53b5ce13887f3fcd721d7fda">SubtractAbsAdd</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b, <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> c) const</td></tr>
<tr class="memdesc:aef58f8dc53b5ce13887f3fcd721d7fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two vectors, taking the absolute value of the result and adding a third vector.  <br /></td></tr>
<tr class="separator:aef58f8dc53b5ce13887f3fcd721d7fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be3752bcceaa1edb4282afe8e43c426" id="r_a1be3752bcceaa1edb4282afe8e43c426"><td class="memItemLeft" align="right" valign="top"><a id="a1be3752bcceaa1edb4282afe8e43c426" name="a1be3752bcceaa1edb4282afe8e43c426"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Multiply</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a1be3752bcceaa1edb4282afe8e43c426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two vectors. <br /></td></tr>
<tr class="separator:a1be3752bcceaa1edb4282afe8e43c426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152aab75b98afae29a3811f8f971248a" id="r_a152aab75b98afae29a3811f8f971248a"><td class="memItemLeft" align="right" valign="top"><a id="a152aab75b98afae29a3811f8f971248a" name="a152aab75b98afae29a3811f8f971248a"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Multiply</b> (<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> b) const</td></tr>
<tr class="memdesc:a152aab75b98afae29a3811f8f971248a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a scalar value. <br /></td></tr>
<tr class="separator:a152aab75b98afae29a3811f8f971248a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7312a8d9dd78169c30efe0411674278c" id="r_a7312a8d9dd78169c30efe0411674278c"><td class="memItemLeft" align="right" valign="top"><a id="a7312a8d9dd78169c30efe0411674278c" name="a7312a8d9dd78169c30efe0411674278c"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Multiply</b> (<a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a> b) const</td></tr>
<tr class="memdesc:a7312a8d9dd78169c30efe0411674278c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a lane value. <br /></td></tr>
<tr class="separator:a7312a8d9dd78169c30efe0411674278c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e88de1db257a3149187bdb751c7dde" id="r_a23e88de1db257a3149187bdb751c7dde"><td class="memTemplParams" colspan="2"><a id="a23e88de1db257a3149187bdb751c7dde" name="a23e88de1db257a3149187bdb751c7dde"></a>
template&lt;size_t LaneIndex&gt; </td></tr>
<tr class="memitem:a23e88de1db257a3149187bdb751c7dde"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Multiply</b> (<a class="el" href="#a42b8f34739c804799a601bdeabedc7ec">const_lane_type</a>&lt; LaneIndex &gt; b) const</td></tr>
<tr class="memdesc:a23e88de1db257a3149187bdb751c7dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a lane value. <br /></td></tr>
<tr class="separator:a23e88de1db257a3149187bdb751c7dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30eb1bff5f1953844facf92590d1d5ed" id="r_a30eb1bff5f1953844facf92590d1d5ed"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30eb1bff5f1953844facf92590d1d5ed">MultiplyAdd</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b, <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> c) const</td></tr>
<tr class="memdesc:a30eb1bff5f1953844facf92590d1d5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two vectors and add a third vector.  <br /></td></tr>
<tr class="separator:a30eb1bff5f1953844facf92590d1d5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4151310ed078d80405b9ab9787fc987" id="r_ac4151310ed078d80405b9ab9787fc987"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4151310ed078d80405b9ab9787fc987">MultiplyAdd</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b, <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> c) const</td></tr>
<tr class="memdesc:ac4151310ed078d80405b9ab9787fc987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a scalar value and add a third vector.  <br /></td></tr>
<tr class="separator:ac4151310ed078d80405b9ab9787fc987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2910bb5d1aed95652f6df336f2184142" id="r_a2910bb5d1aed95652f6df336f2184142"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2910bb5d1aed95652f6df336f2184142">MultiplyAdd</a> (<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> b, <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> c) const</td></tr>
<tr class="memdesc:a2910bb5d1aed95652f6df336f2184142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a scalar value and add a third vector.  <br /></td></tr>
<tr class="separator:a2910bb5d1aed95652f6df336f2184142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1e4ae65dd295566c22882412d9f047" id="r_a2c1e4ae65dd295566c22882412d9f047"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c1e4ae65dd295566c22882412d9f047">MultiplyAdd</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b, <a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a> c) const</td></tr>
<tr class="memdesc:a2c1e4ae65dd295566c22882412d9f047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a lane value and add a third vector.  <br /></td></tr>
<tr class="separator:a2c1e4ae65dd295566c22882412d9f047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7c5717ca19532b50c9139d26d0d649" id="r_aec7c5717ca19532b50c9139d26d0d649"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec7c5717ca19532b50c9139d26d0d649">MultiplyAdd</a> (<a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a> b, <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> c) const</td></tr>
<tr class="memdesc:aec7c5717ca19532b50c9139d26d0d649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a lane value and add a third vector.  <br /></td></tr>
<tr class="separator:aec7c5717ca19532b50c9139d26d0d649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3fe437a4fc1527fcd9037dc842551a" id="r_a5f3fe437a4fc1527fcd9037dc842551a"><td class="memTemplParams" colspan="2">template&lt;size_t LaneIndex&gt; </td></tr>
<tr class="memitem:a5f3fe437a4fc1527fcd9037dc842551a"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5f3fe437a4fc1527fcd9037dc842551a">MultiplyAdd</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b, <a class="el" href="#a42b8f34739c804799a601bdeabedc7ec">const_lane_type</a>&lt; LaneIndex &gt; c) const</td></tr>
<tr class="memdesc:a5f3fe437a4fc1527fcd9037dc842551a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a lane value and add a third vector.  <br /></td></tr>
<tr class="separator:a5f3fe437a4fc1527fcd9037dc842551a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778eabd1a2014cce0a3dee20e038d44b" id="r_a778eabd1a2014cce0a3dee20e038d44b"><td class="memTemplParams" colspan="2">template&lt;size_t LaneIndex&gt; </td></tr>
<tr class="memitem:a778eabd1a2014cce0a3dee20e038d44b"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a778eabd1a2014cce0a3dee20e038d44b">MultiplyAdd</a> (<a class="el" href="#a42b8f34739c804799a601bdeabedc7ec">const_lane_type</a>&lt; LaneIndex &gt; b, <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> c) const</td></tr>
<tr class="memdesc:a778eabd1a2014cce0a3dee20e038d44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a lane value and add a third vector.  <br /></td></tr>
<tr class="separator:a778eabd1a2014cce0a3dee20e038d44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f15cb6e2ba71f90ac0927bece0250c" id="r_a18f15cb6e2ba71f90ac0927bece0250c"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18f15cb6e2ba71f90ac0927bece0250c">MultiplySubtract</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b, <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> c) const</td></tr>
<tr class="memdesc:a18f15cb6e2ba71f90ac0927bece0250c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two vectors and subtract from a third vector.  <br /></td></tr>
<tr class="separator:a18f15cb6e2ba71f90ac0927bece0250c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75462f482302303584296d30a5f1b36a" id="r_a75462f482302303584296d30a5f1b36a"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75462f482302303584296d30a5f1b36a">MultiplySubtract</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b, <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> c) const</td></tr>
<tr class="memdesc:a75462f482302303584296d30a5f1b36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a scalar value and subtract from a third vector.  <br /></td></tr>
<tr class="separator:a75462f482302303584296d30a5f1b36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa89c23ca17233b39740179621e16201" id="r_aaa89c23ca17233b39740179621e16201"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa89c23ca17233b39740179621e16201">MultiplySubtract</a> (<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> b, <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> c) const</td></tr>
<tr class="memdesc:aaa89c23ca17233b39740179621e16201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a scalar value and subtract from a third vector.  <br /></td></tr>
<tr class="separator:aaa89c23ca17233b39740179621e16201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044130cfb0e6b776a94989d5e33a5e3b" id="r_a044130cfb0e6b776a94989d5e33a5e3b"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a044130cfb0e6b776a94989d5e33a5e3b">MultiplySubtract</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b, <a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a> c) const</td></tr>
<tr class="memdesc:a044130cfb0e6b776a94989d5e33a5e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a lane value and subtract from a third vector.  <br /></td></tr>
<tr class="separator:a044130cfb0e6b776a94989d5e33a5e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318aca048c171533be145f994736dfd8" id="r_a318aca048c171533be145f994736dfd8"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a318aca048c171533be145f994736dfd8">MultiplyQMax</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> v) const</td></tr>
<tr class="memdesc:a318aca048c171533be145f994736dfd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two QMax fixed-point vectors, returning a fixed-point product.  <br /></td></tr>
<tr class="separator:a318aca048c171533be145f994736dfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9971d8dd8b00595462f04f05658282f" id="r_ae9971d8dd8b00595462f04f05658282f"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9971d8dd8b00595462f04f05658282f">MultiplyQMax</a> (<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> s) const</td></tr>
<tr class="memdesc:ae9971d8dd8b00595462f04f05658282f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a QMax fixed-point vector by a scalar value, returning a fixed-point product.  <br /></td></tr>
<tr class="separator:ae9971d8dd8b00595462f04f05658282f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae209b4ccfdca4ddd68ec1dad3d8992ab" id="r_ae209b4ccfdca4ddd68ec1dad3d8992ab"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae209b4ccfdca4ddd68ec1dad3d8992ab">MultiplyQMax</a> (<a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a> l) const</td></tr>
<tr class="memdesc:ae209b4ccfdca4ddd68ec1dad3d8992ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a QMax fixed-point vector by a lane value, returning a fixed-point product.  <br /></td></tr>
<tr class="separator:ae209b4ccfdca4ddd68ec1dad3d8992ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e19b56008531293076027a9b9b8153" id="r_a16e19b56008531293076027a9b9b8153"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16e19b56008531293076027a9b9b8153">MultiplyRoundQMax</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> v) const</td></tr>
<tr class="memdesc:a16e19b56008531293076027a9b9b8153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two fixed-point vectors, returning a fixed-point product.  <br /></td></tr>
<tr class="separator:a16e19b56008531293076027a9b9b8153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30cea740a1b206d0027eeb8c8248621" id="r_ac30cea740a1b206d0027eeb8c8248621"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac30cea740a1b206d0027eeb8c8248621">MultiplyRoundQMax</a> (<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> s) const</td></tr>
<tr class="memdesc:ac30cea740a1b206d0027eeb8c8248621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a fixed-point vector by a scalar value, returning a fixed-point product.  <br /></td></tr>
<tr class="separator:ac30cea740a1b206d0027eeb8c8248621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bf1284aba99676b4ea555b0ba65ea9" id="r_a24bf1284aba99676b4ea555b0ba65ea9"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24bf1284aba99676b4ea555b0ba65ea9">MultiplyRoundQMax</a> (<a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a> l) const</td></tr>
<tr class="memdesc:a24bf1284aba99676b4ea555b0ba65ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a fixed-point vector by a lane value, returning a fixed-point product.  <br /></td></tr>
<tr class="separator:a24bf1284aba99676b4ea555b0ba65ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91da6dc5608aae40cc630ac5b4fb731" id="r_ad91da6dc5608aae40cc630ac5b4fb731"><td class="memItemLeft" align="right" valign="top"><a id="ad91da6dc5608aae40cc630ac5b4fb731" name="ad91da6dc5608aae40cc630ac5b4fb731"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Absolute</b> () const</td></tr>
<tr class="memdesc:ad91da6dc5608aae40cc630ac5b4fb731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute value of the vector. <br /></td></tr>
<tr class="separator:ad91da6dc5608aae40cc630ac5b4fb731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4ad8617da38f5e4a9b9094ede736b5" id="r_a1b4ad8617da38f5e4a9b9094ede736b5"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b4ad8617da38f5e4a9b9094ede736b5">ReciprocalEstimate</a> () const</td></tr>
<tr class="memdesc:a1b4ad8617da38f5e4a9b9094ede736b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 / value, using an estimate for speed  <br /></td></tr>
<tr class="separator:a1b4ad8617da38f5e4a9b9094ede736b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7a52e529b6894c26527f5a8ccbca20" id="r_a7f7a52e529b6894c26527f5a8ccbca20"><td class="memTemplParams" colspan="2">template&lt;typename arg_type&gt; <br />
requires (is_one_of&lt;arg_type, <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>, <a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a>&gt; || std::is_convertible_v&lt;arg_type, <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&gt; || std::is_convertible_v&lt;arg_type, <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>&gt;)</td></tr>
<tr class="memitem:a7f7a52e529b6894c26527f5a8ccbca20"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7f7a52e529b6894c26527f5a8ccbca20">MultiplyAddQMax</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b, arg_type c) const</td></tr>
<tr class="memdesc:a7f7a52e529b6894c26527f5a8ccbca20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-add three fixed-point vectors, returning a fixed-point sum.  <br /></td></tr>
<tr class="separator:a7f7a52e529b6894c26527f5a8ccbca20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f0a102c8dd8cc82acd9710ddc15cd1" id="r_a45f0a102c8dd8cc82acd9710ddc15cd1"><td class="memTemplParams" colspan="2">template&lt;typename arg_type&gt; <br />
requires (is_one_of&lt;arg_type, <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>, <a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a>&gt; || std::is_convertible_v&lt;arg_type, <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&gt; || std::is_convertible_v&lt;arg_type, <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>&gt;)</td></tr>
<tr class="memitem:a45f0a102c8dd8cc82acd9710ddc15cd1"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a45f0a102c8dd8cc82acd9710ddc15cd1">MultiplyRoundAddQMax</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b, arg_type c) const</td></tr>
<tr class="memdesc:a45f0a102c8dd8cc82acd9710ddc15cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-round-add three fixed-point vectors, returning a fixed-point sum.  <br /></td></tr>
<tr class="separator:a45f0a102c8dd8cc82acd9710ddc15cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef7bd6575089b4820bfdf71bd9ab5b7" id="r_a7ef7bd6575089b4820bfdf71bd9ab5b7"><td class="memItemLeft" align="right" valign="top"><a id="a7ef7bd6575089b4820bfdf71bd9ab5b7" name="a7ef7bd6575089b4820bfdf71bd9ab5b7"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Divide</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a7ef7bd6575089b4820bfdf71bd9ab5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide two vectors. <br /></td></tr>
<tr class="separator:a7ef7bd6575089b4820bfdf71bd9ab5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083eb76b876a725e5c3f17c3154309f1" id="r_a083eb76b876a725e5c3f17c3154309f1"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a083eb76b876a725e5c3f17c3154309f1">Modulo</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a083eb76b876a725e5c3f17c3154309f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the modulo of two vectors.  <br /></td></tr>
<tr class="separator:a083eb76b876a725e5c3f17c3154309f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6632c9d68aa2e4a4049b5011549e8199" id="r_a6632c9d68aa2e4a4049b5011549e8199"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6632c9d68aa2e4a4049b5011549e8199">Modulo</a> (<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> b) const</td></tr>
<tr class="memdesc:a6632c9d68aa2e4a4049b5011549e8199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the modulo of a vector and a scalar value.  <br /></td></tr>
<tr class="separator:a6632c9d68aa2e4a4049b5011549e8199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51663230ed752a2cff604c1d380a547f" id="r_a51663230ed752a2cff604c1d380a547f"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51663230ed752a2cff604c1d380a547f">Max</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a51663230ed752a2cff604c1d380a547f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the lanes of two vectors, copying the larger of each lane to the result.  <br /></td></tr>
<tr class="separator:a51663230ed752a2cff604c1d380a547f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fded6d76878d39a236435acccb3eeb" id="r_ae9fded6d76878d39a236435acccb3eeb"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9fded6d76878d39a236435acccb3eeb">Min</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:ae9fded6d76878d39a236435acccb3eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the lanes of two vectors, copying the smaller of each lane to the result.  <br /></td></tr>
<tr class="separator:ae9fded6d76878d39a236435acccb3eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3decc478c1472bc120da30c8cbd349b0" id="r_a3decc478c1472bc120da30c8cbd349b0"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#abb337d1f5ce5ced64b5a234b8ee9ee05">argon_bool_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3decc478c1472bc120da30c8cbd349b0">Equal</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a3decc478c1472bc120da30c8cbd349b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the lanes of two vectors, setting the result lane's bits to ON if are equal.  <br /></td></tr>
<tr class="separator:a3decc478c1472bc120da30c8cbd349b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b12a632fc5646f7ed4751d07b28b13c" id="r_a7b12a632fc5646f7ed4751d07b28b13c"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#abb337d1f5ce5ced64b5a234b8ee9ee05">argon_bool_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b12a632fc5646f7ed4751d07b28b13c">GreaterThanOrEqual</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a7b12a632fc5646f7ed4751d07b28b13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the lanes of two vectors, setting the result lane's bits to ON if a is greater than or equal to b.  <br /></td></tr>
<tr class="separator:a7b12a632fc5646f7ed4751d07b28b13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c34bfe1567cedd121d6945031ff8687" id="r_a1c34bfe1567cedd121d6945031ff8687"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#abb337d1f5ce5ced64b5a234b8ee9ee05">argon_bool_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c34bfe1567cedd121d6945031ff8687">LessThanOrEqual</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a1c34bfe1567cedd121d6945031ff8687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the lanes of two vectors, setting the result lane's bits to ON if a is less than or equal to b.  <br /></td></tr>
<tr class="separator:a1c34bfe1567cedd121d6945031ff8687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919a7820afce4ddf71dcd8afc11db36b" id="r_a919a7820afce4ddf71dcd8afc11db36b"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#abb337d1f5ce5ced64b5a234b8ee9ee05">argon_bool_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a919a7820afce4ddf71dcd8afc11db36b">GreaterThan</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a919a7820afce4ddf71dcd8afc11db36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the lanes of two vectors, setting the result lane's bits to ON if a is greater than b.  <br /></td></tr>
<tr class="separator:a919a7820afce4ddf71dcd8afc11db36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b11498ebe5371b468f10c76091e9f1" id="r_a66b11498ebe5371b468f10c76091e9f1"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#abb337d1f5ce5ced64b5a234b8ee9ee05">argon_bool_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66b11498ebe5371b468f10c76091e9f1">LessThan</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a66b11498ebe5371b468f10c76091e9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the lanes of two vectors, setting the result lane's bits to ON if a is less than b.  <br /></td></tr>
<tr class="separator:a66b11498ebe5371b468f10c76091e9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235f1983552e5049a465dbce9301f0b1" id="r_a235f1983552e5049a465dbce9301f0b1"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a235f1983552e5049a465dbce9301f0b1">ShiftLeft</a> (<a class="el" href="namespaceargon_1_1helpers.html#a78d315330017f0fe0a14cccd2d5b318a">helpers::ArgonFor_t</a>&lt; simd::make_signed_t&lt; Bool_t&lt; VectorType &gt; &gt; &gt; b) const</td></tr>
<tr class="memdesc:a235f1983552e5049a465dbce9301f0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elemnets of the vector to the left by a specified number of bits.  <br /></td></tr>
<tr class="separator:a235f1983552e5049a465dbce9301f0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339ac134c3ae1143e6a7244e5bd490ff" id="r_a339ac134c3ae1143e6a7244e5bd490ff"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a339ac134c3ae1143e6a7244e5bd490ff">ShiftLeft</a> (std::make_signed_t&lt; simd::Scalar_t&lt; Bool_t&lt; VectorType &gt; &gt; &gt; n) const</td></tr>
<tr class="memdesc:a339ac134c3ae1143e6a7244e5bd490ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the vector to the left by a specified number of bits.  <br /></td></tr>
<tr class="separator:a339ac134c3ae1143e6a7244e5bd490ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa519dbdec10abee1979bfa0dd01c18d6" id="r_aa519dbdec10abee1979bfa0dd01c18d6"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:aa519dbdec10abee1979bfa0dd01c18d6"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa519dbdec10abee1979bfa0dd01c18d6">ShiftLeft</a> () const</td></tr>
<tr class="memdesc:aa519dbdec10abee1979bfa0dd01c18d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the vector to the left by a specified number of bits.  <br /></td></tr>
<tr class="separator:aa519dbdec10abee1979bfa0dd01c18d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e6c9025b5476bcfd160716ffdf3c40" id="r_aa8e6c9025b5476bcfd160716ffdf3c40"><td class="memItemLeft" align="right" valign="top"><a id="aa8e6c9025b5476bcfd160716ffdf3c40" name="aa8e6c9025b5476bcfd160716ffdf3c40"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ShiftLeftSaturate</b> (<a class="el" href="namespaceargon_1_1helpers.html#a78d315330017f0fe0a14cccd2d5b318a">helpers::ArgonFor_t</a>&lt; simd::make_signed_t&lt; Bool_t&lt; VectorType &gt; &gt; &gt; b) const</td></tr>
<tr class="memdesc:aa8e6c9025b5476bcfd160716ffdf3c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the vector to the left by a specified number of bits, saturating the result. <br /></td></tr>
<tr class="separator:aa8e6c9025b5476bcfd160716ffdf3c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b9242629763e5d38a72ccb87d42f88" id="r_a08b9242629763e5d38a72ccb87d42f88"><td class="memItemLeft" align="right" valign="top"><a id="a08b9242629763e5d38a72ccb87d42f88" name="a08b9242629763e5d38a72ccb87d42f88"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ShiftLeftRound</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a08b9242629763e5d38a72ccb87d42f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the vector to the left by a specified number of bits, rounding the result. <br /></td></tr>
<tr class="separator:a08b9242629763e5d38a72ccb87d42f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1b3b5a833aa62ee6f3b6ffb46e78d0" id="r_a6b1b3b5a833aa62ee6f3b6ffb46e78d0"><td class="memItemLeft" align="right" valign="top"><a id="a6b1b3b5a833aa62ee6f3b6ffb46e78d0" name="a6b1b3b5a833aa62ee6f3b6ffb46e78d0"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ShiftLeftRoundSaturate</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a6b1b3b5a833aa62ee6f3b6ffb46e78d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the vector to the left by a specified number of bits, rounding and saturating the result. <br /></td></tr>
<tr class="separator:a6b1b3b5a833aa62ee6f3b6ffb46e78d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad381cc8d7c155e3bee7e5dfbde36527" id="r_aad381cc8d7c155e3bee7e5dfbde36527"><td class="memTemplParams" colspan="2"><a id="aad381cc8d7c155e3bee7e5dfbde36527" name="aad381cc8d7c155e3bee7e5dfbde36527"></a>
template&lt;int n&gt; </td></tr>
<tr class="memitem:aad381cc8d7c155e3bee7e5dfbde36527"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ShiftLeftSaturate</b> () const</td></tr>
<tr class="memdesc:aad381cc8d7c155e3bee7e5dfbde36527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the vector to the left by a specified number of bits, saturating the result. <br /></td></tr>
<tr class="separator:aad381cc8d7c155e3bee7e5dfbde36527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4e1837e5f94e74ef301cbfee9d58bb" id="r_a5a4e1837e5f94e74ef301cbfee9d58bb"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:a5a4e1837e5f94e74ef301cbfee9d58bb"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5a4e1837e5f94e74ef301cbfee9d58bb">ShiftLeftInsert</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a5a4e1837e5f94e74ef301cbfee9d58bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the vector to the left by a specified number of bits, and then OR the result with another vector masked to the number of shift bits.  <br /></td></tr>
<tr class="separator:a5a4e1837e5f94e74ef301cbfee9d58bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f68e1c699bfaf2c2ee4f41ee8f9f0c0" id="r_a6f68e1c699bfaf2c2ee4f41ee8f9f0c0"><td class="memTemplParams" colspan="2"><a id="a6f68e1c699bfaf2c2ee4f41ee8f9f0c0" name="a6f68e1c699bfaf2c2ee4f41ee8f9f0c0"></a>
template&lt;int n&gt; </td></tr>
<tr class="memitem:a6f68e1c699bfaf2c2ee4f41ee8f9f0c0"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ShiftRight</b> () const</td></tr>
<tr class="memdesc:a6f68e1c699bfaf2c2ee4f41ee8f9f0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the vector to the right by a specified number of bits. <br /></td></tr>
<tr class="separator:a6f68e1c699bfaf2c2ee4f41ee8f9f0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a975d4a221b47fc57a234df4e4f172" id="r_a87a975d4a221b47fc57a234df4e4f172"><td class="memTemplParams" colspan="2"><a id="a87a975d4a221b47fc57a234df4e4f172" name="a87a975d4a221b47fc57a234df4e4f172"></a>
template&lt;int n&gt; </td></tr>
<tr class="memitem:a87a975d4a221b47fc57a234df4e4f172"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ShiftRightRound</b> () const</td></tr>
<tr class="memdesc:a87a975d4a221b47fc57a234df4e4f172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the vector to the right by a specified number of bits, rounding the result. <br /></td></tr>
<tr class="separator:a87a975d4a221b47fc57a234df4e4f172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd871a0354f515c2b91780d1a2aeb8b" id="r_adfd871a0354f515c2b91780d1a2aeb8b"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:adfd871a0354f515c2b91780d1a2aeb8b"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adfd871a0354f515c2b91780d1a2aeb8b">ShiftRightAccumulate</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:adfd871a0354f515c2b91780d1a2aeb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the <code>b</code> vector to the right by a specified number of bits, and then add the result to this vector.  <br /></td></tr>
<tr class="separator:adfd871a0354f515c2b91780d1a2aeb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c94ab7b62bf793e04388108b643bba7" id="r_a9c94ab7b62bf793e04388108b643bba7"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:a9c94ab7b62bf793e04388108b643bba7"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9c94ab7b62bf793e04388108b643bba7">ShiftRightAccumulateRound</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a9c94ab7b62bf793e04388108b643bba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the <code>b</code> vector to the right by a specified number of bits, and then add the result to this vector.  <br /></td></tr>
<tr class="separator:a9c94ab7b62bf793e04388108b643bba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcff0fce3d0e2568fddb6f0ba115768" id="r_aedcff0fce3d0e2568fddb6f0ba115768"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:aedcff0fce3d0e2568fddb6f0ba115768"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aedcff0fce3d0e2568fddb6f0ba115768">ShiftRightInsert</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:aedcff0fce3d0e2568fddb6f0ba115768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the elements of the vector to the right by a specified number of bits, ORing the result with the vector masked to the number of shift bits.  <br /></td></tr>
<tr class="separator:aedcff0fce3d0e2568fddb6f0ba115768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e16481307865c0d17cbc73784e83a0" id="r_aa2e16481307865c0d17cbc73784e83a0"><td class="memTemplParams" colspan="2">template&lt;size_t lane&gt; </td></tr>
<tr class="memitem:aa2e16481307865c0d17cbc73784e83a0"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa2e16481307865c0d17cbc73784e83a0">LoadToLane</a> (const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *ptr)</td></tr>
<tr class="memdesc:aa2e16481307865c0d17cbc73784e83a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a lane from a pointer.  <br /></td></tr>
<tr class="separator:aa2e16481307865c0d17cbc73784e83a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42451f1aadb8a99656980b90961423da" id="r_a42451f1aadb8a99656980b90961423da"><td class="memItemLeft" align="right" valign="top">ace void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42451f1aadb8a99656980b90961423da">StoreTo</a> (<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *ptr) const</td></tr>
<tr class="memdesc:a42451f1aadb8a99656980b90961423da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the vector to a pointer.  <br /></td></tr>
<tr class="separator:a42451f1aadb8a99656980b90961423da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f5ef376e9294faa4fe36be434a7a50" id="r_a72f5ef376e9294faa4fe36be434a7a50"><td class="memTemplParams" colspan="2">template&lt;int LaneIndex&gt; </td></tr>
<tr class="memitem:a72f5ef376e9294faa4fe36be434a7a50"><td class="memTemplItemLeft" align="right" valign="top">ace void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72f5ef376e9294faa4fe36be434a7a50">StoreLaneTo</a> (<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *ptr)</td></tr>
<tr class="memdesc:a72f5ef376e9294faa4fe36be434a7a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a lane of the vector to a pointer.  <br /></td></tr>
<tr class="separator:a72f5ef376e9294faa4fe36be434a7a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2775284e15105fd173cace27e941b41b" id="r_a2775284e15105fd173cace27e941b41b"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2775284e15105fd173cace27e941b41b">PairwiseAdd</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a2775284e15105fd173cace27e941b41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pairwise ops.  <br /></td></tr>
<tr class="separator:a2775284e15105fd173cace27e941b41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6375e9154485e6930fcc97fe052cc2" id="r_a4e6375e9154485e6930fcc97fe052cc2"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e6375e9154485e6930fcc97fe052cc2">PairwiseMax</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a4e6375e9154485e6930fcc97fe052cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the maximum of each pair of lanes in the two vectors.  <br /></td></tr>
<tr class="separator:a4e6375e9154485e6930fcc97fe052cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02104df04e935b50cb70a2484c12f2d2" id="r_a02104df04e935b50cb70a2484c12f2d2"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02104df04e935b50cb70a2484c12f2d2">PairwiseMin</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a02104df04e935b50cb70a2484c12f2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the maximum of each pair of lanes in the two vectors.  <br /></td></tr>
<tr class="separator:a02104df04e935b50cb70a2484c12f2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd51e224bfbdc19aed595a95dd9b737" id="r_a4fd51e224bfbdc19aed595a95dd9b737"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fd51e224bfbdc19aed595a95dd9b737">BitwiseNot</a> () const</td></tr>
<tr class="memdesc:a4fd51e224bfbdc19aed595a95dd9b737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise ops.  <br /></td></tr>
<tr class="separator:a4fd51e224bfbdc19aed595a95dd9b737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce169ea39053ca043aa01d20163c8b1" id="r_a5ce169ea39053ca043aa01d20163c8b1"><td class="memItemLeft" align="right" valign="top"><a id="a5ce169ea39053ca043aa01d20163c8b1" name="a5ce169ea39053ca043aa01d20163c8b1"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BitwiseAnd</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a5ce169ea39053ca043aa01d20163c8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise AND of the vector with another vector. <br /></td></tr>
<tr class="separator:a5ce169ea39053ca043aa01d20163c8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae097bd673f14aa4d1cdf350819976618" id="r_ae097bd673f14aa4d1cdf350819976618"><td class="memItemLeft" align="right" valign="top"><a id="ae097bd673f14aa4d1cdf350819976618" name="ae097bd673f14aa4d1cdf350819976618"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BitwiseOr</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:ae097bd673f14aa4d1cdf350819976618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise OR of the vector with another vector. <br /></td></tr>
<tr class="separator:ae097bd673f14aa4d1cdf350819976618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fdd94cbb4d6780de4337dd96e0d763" id="r_af2fdd94cbb4d6780de4337dd96e0d763"><td class="memItemLeft" align="right" valign="top"><a id="af2fdd94cbb4d6780de4337dd96e0d763" name="af2fdd94cbb4d6780de4337dd96e0d763"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BitwiseXor</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:af2fdd94cbb4d6780de4337dd96e0d763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise XOR of the vector with another vector. <br /></td></tr>
<tr class="separator:af2fdd94cbb4d6780de4337dd96e0d763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34329dd0e9f65efb3c85f0c0323ceed9" id="r_a34329dd0e9f65efb3c85f0c0323ceed9"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34329dd0e9f65efb3c85f0c0323ceed9">BitwiseOrNot</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a34329dd0e9f65efb3c85f0c0323ceed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise OR of the vector with the NOT of another vector.  <br /></td></tr>
<tr class="separator:a34329dd0e9f65efb3c85f0c0323ceed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf81303d33688352129c9c6c5acbec54" id="r_adf81303d33688352129c9c6c5acbec54"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf81303d33688352129c9c6c5acbec54">BitwiseAndNot</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:adf81303d33688352129c9c6c5acbec54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise AND of the vector with the NOT of another vector.  <br /></td></tr>
<tr class="separator:adf81303d33688352129c9c6c5acbec54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade26621c9a471b9c5ccbde3bcc37db93" id="r_ade26621c9a471b9c5ccbde3bcc37db93"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade26621c9a471b9c5ccbde3bcc37db93">BitwiseClear</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:ade26621c9a471b9c5ccbde3bcc37db93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise AND of the vector with the NOT of another vector.     <br /></td></tr>
<tr class="separator:ade26621c9a471b9c5ccbde3bcc37db93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8cf48035785f21276b14acb20fa8ae" id="r_aaf8cf48035785f21276b14acb20fa8ae"><td class="memTemplParams" colspan="2">template&lt;typename ArgType&gt; <br />
requires std::is_unsigned_v&lt;<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>&gt;</td></tr>
<tr class="memitem:aaf8cf48035785f21276b14acb20fa8ae"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaf8cf48035785f21276b14acb20fa8ae">BitwiseSelect</a> (ArgType true_value, ArgType false_value) const</td></tr>
<tr class="memdesc:aaf8cf48035785f21276b14acb20fa8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise select between two vectors, using the current vector as a mask.  <br /></td></tr>
<tr class="separator:aaf8cf48035785f21276b14acb20fa8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88e29f9051bfa88b952f58528e2489c" id="r_ad88e29f9051bfa88b952f58528e2489c"><td class="memTemplParams" colspan="2">template&lt;typename ArgType&gt; <br />
requires std::is_unsigned_v&lt;<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>&gt;</td></tr>
<tr class="memitem:ad88e29f9051bfa88b952f58528e2489c"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad88e29f9051bfa88b952f58528e2489c">Select</a> (ArgType true_value, ArgType false_value) const</td></tr>
<tr class="memdesc:ad88e29f9051bfa88b952f58528e2489c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise select between two vectors, using the current vector as a mask.     <br /></td></tr>
<tr class="separator:ad88e29f9051bfa88b952f58528e2489c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd82746876ae1dce97036fda72bcd33" id="r_a4bd82746876ae1dce97036fda72bcd33"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a88f641dc73c423f906d60554a58e763f">predicate_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bd82746876ae1dce97036fda72bcd33">CompareTestNonzero</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a4bd82746876ae1dce97036fda72bcd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ands the current vector with the given vector, then checks if nonzero.  <br /></td></tr>
<tr class="separator:a4bd82746876ae1dce97036fda72bcd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa39b01b6f592232a4b3150f660b8aa" id="r_a9fa39b01b6f592232a4b3150f660b8aa"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a88f641dc73c423f906d60554a58e763f">predicate_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fa39b01b6f592232a4b3150f660b8aa">TestNonzero</a> () const</td></tr>
<tr class="memdesc:a9fa39b01b6f592232a4b3150f660b8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ands the current vector with the given vector, then checks if nonzero.     <br /></td></tr>
<tr class="separator:a9fa39b01b6f592232a4b3150f660b8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3565b12089d333da836e7ba087834380" id="r_a3565b12089d333da836e7ba087834380"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="namespaceargon_1_1helpers.html#a78d315330017f0fe0a14cccd2d5b318a">helpers::ArgonFor_t</a>&lt; simd::make_signed_t&lt; Bool_t&lt; VectorType &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3565b12089d333da836e7ba087834380">CountLeadingSignBits</a> () const</td></tr>
<tr class="memdesc:a3565b12089d333da836e7ba087834380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of consecutive bits following the sign bit that are set to the same value as the sign bit.  <br /></td></tr>
<tr class="separator:a3565b12089d333da836e7ba087834380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d2af44ba36962119d4a23d8b9be3b7" id="r_ae9d2af44ba36962119d4a23d8b9be3b7"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9d2af44ba36962119d4a23d8b9be3b7">CountLeadingZeroBits</a> () const</td></tr>
<tr class="memdesc:ae9d2af44ba36962119d4a23d8b9be3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of consecutive top bits that are set to zero.  <br /></td></tr>
<tr class="separator:ae9d2af44ba36962119d4a23d8b9be3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4938dd3f55ba817c166bc86278bd5dd6" id="r_a4938dd3f55ba817c166bc86278bd5dd6"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4938dd3f55ba817c166bc86278bd5dd6">CountActiveBits</a> () const</td></tr>
<tr class="memdesc:a4938dd3f55ba817c166bc86278bd5dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of bits that are set to one in the vector.  <br /></td></tr>
<tr class="separator:a4938dd3f55ba817c166bc86278bd5dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6651697b922476d1c5e89234d662e83c" id="r_a6651697b922476d1c5e89234d662e83c"><td class="memItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6651697b922476d1c5e89234d662e83c">Popcount</a> () const</td></tr>
<tr class="memdesc:a6651697b922476d1c5e89234d662e83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of bits that are set to one in the vector.     <br /></td></tr>
<tr class="separator:a6651697b922476d1c5e89234d662e83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190a0c3091b13281aabf213875a5ee69" id="r_a190a0c3091b13281aabf213875a5ee69"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:a190a0c3091b13281aabf213875a5ee69"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a190a0c3091b13281aabf213875a5ee69">Extract</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a190a0c3091b13281aabf213875a5ee69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract n elements from the lower end of the operand, and the remaining elements from the top end of this vector, combining them into the result vector.  <br /></td></tr>
<tr class="separator:a190a0c3091b13281aabf213875a5ee69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73d231bc696bba1cf47f8065c7c0c3d" id="r_ab73d231bc696bba1cf47f8065c7c0c3d"><td class="memItemLeft" align="right" valign="top"><a id="ab73d231bc696bba1cf47f8065c7c0c3d" name="ab73d231bc696bba1cf47f8065c7c0c3d"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Reverse64bit</b> () const</td></tr>
<tr class="separator:ab73d231bc696bba1cf47f8065c7c0c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63791a6f73a2f16fcbbcc6c3a204a37c" id="r_a63791a6f73a2f16fcbbcc6c3a204a37c"><td class="memItemLeft" align="right" valign="top"><a id="a63791a6f73a2f16fcbbcc6c3a204a37c" name="a63791a6f73a2f16fcbbcc6c3a204a37c"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Reverse32bit</b> () const</td></tr>
<tr class="separator:a63791a6f73a2f16fcbbcc6c3a204a37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5308d256c71e84733d45a7e8e0a5f4f" id="r_af5308d256c71e84733d45a7e8e0a5f4f"><td class="memItemLeft" align="right" valign="top"><a id="af5308d256c71e84733d45a7e8e0a5f4f" name="af5308d256c71e84733d45a7e8e0a5f4f"></a>
ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Reverse16bit</b> () const</td></tr>
<tr class="separator:af5308d256c71e84733d45a7e8e0a5f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94643eaec4a28cee8492f9bacba8b6eb" id="r_a94643eaec4a28cee8492f9bacba8b6eb"><td class="memItemLeft" align="right" valign="top">ace std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94643eaec4a28cee8492f9bacba8b6eb">ZipWith</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a94643eaec4a28cee8492f9bacba8b6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip two vectors together, returning two vectors of pairs.  <br /></td></tr>
<tr class="separator:a94643eaec4a28cee8492f9bacba8b6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378a84364d98127adb2888a23d260790" id="r_a378a84364d98127adb2888a23d260790"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a378a84364d98127adb2888a23d260790">UnzipWith</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b)</td></tr>
<tr class="memdesc:a378a84364d98127adb2888a23d260790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unzip two vectors, returning two vectors of pairs.  <br /></td></tr>
<tr class="separator:a378a84364d98127adb2888a23d260790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea12f326a728a3264306ac6266f4344" id="r_a0ea12f326a728a3264306ac6266f4344"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ea12f326a728a3264306ac6266f4344">TransposeWith</a> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> b) const</td></tr>
<tr class="memdesc:a0ea12f326a728a3264306ac6266f4344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a 2x2 matrix transpose on two vectors, returning two vectors of pairs.  <br /></td></tr>
<tr class="separator:a0ea12f326a728a3264306ac6266f4344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89da2cf9061ca661d35df333a7d7356" id="r_ad89da2cf9061ca661d35df333a7d7356"><td class="memTemplParams" colspan="2"><a id="ad89da2cf9061ca661d35df333a7d7356" name="ad89da2cf9061ca661d35df333a7d7356"></a>
template&lt;typename FuncType&gt; <br />
requires std::convertible_to&lt;FuncType, std::function&lt;<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>(<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>)&gt;&gt;</td></tr>
<tr class="memitem:ad89da2cf9061ca661d35df333a7d7356"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (FuncType body) const</td></tr>
<tr class="separator:ad89da2cf9061ca661d35df333a7d7356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fb6dfb678dfe1399871be7831b1aba" id="r_a94fb6dfb678dfe1399871be7831b1aba"><td class="memTemplParams" colspan="2"><a id="a94fb6dfb678dfe1399871be7831b1aba" name="a94fb6dfb678dfe1399871be7831b1aba"></a>
template&lt;typename FuncType&gt; <br />
requires std::convertible_to&lt;FuncType, std::function&lt;<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>(<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>, int)&gt;&gt;</td></tr>
<tr class="memitem:a94fb6dfb678dfe1399871be7831b1aba"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_with_index</b> (FuncType body) const</td></tr>
<tr class="separator:a94fb6dfb678dfe1399871be7831b1aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0643beb3d4bacd8da58a14899db6451a" id="r_a0643beb3d4bacd8da58a14899db6451a"><td class="memTemplParams" colspan="2"><a id="a0643beb3d4bacd8da58a14899db6451a" name="a0643beb3d4bacd8da58a14899db6451a"></a>
template&lt;typename FuncType&gt; <br />
requires std::convertible_to&lt;FuncType, std::function&lt;<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>(<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>, <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>)&gt;&gt;</td></tr>
<tr class="memitem:a0643beb3d4bacd8da58a14899db6451a"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map2</b> (<a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> other, FuncType body) const</td></tr>
<tr class="separator:a0643beb3d4bacd8da58a14899db6451a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d7fcfcb9b28cd8e1a13e541b84e819" id="r_a51d7fcfcb9b28cd8e1a13e541b84e819"><td class="memTemplParams" colspan="2"><a id="a51d7fcfcb9b28cd8e1a13e541b84e819" name="a51d7fcfcb9b28cd8e1a13e541b84e819"></a>
template&lt;typename FuncType&gt; <br />
requires std::convertible_to&lt;FuncType, std::function&lt;void(<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>&amp;)&gt;&gt;</td></tr>
<tr class="memitem:a51d7fcfcb9b28cd8e1a13e541b84e819"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>each_lane</b> (FuncType body)</td></tr>
<tr class="separator:a51d7fcfcb9b28cd8e1a13e541b84e819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ee88bc6983d2e957294e50e020d3d8" id="r_a74ee88bc6983d2e957294e50e020d3d8"><td class="memTemplParams" colspan="2"><a id="a74ee88bc6983d2e957294e50e020d3d8" name="a74ee88bc6983d2e957294e50e020d3d8"></a>
template&lt;typename FuncType&gt; <br />
requires std::convertible_to&lt;FuncType, std::function&lt;void(<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>&amp;, int)&gt;&gt;</td></tr>
<tr class="memitem:a74ee88bc6983d2e957294e50e020d3d8"><td class="memTemplItemLeft" align="right" valign="top">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>each_lane_with_index</b> (FuncType body)</td></tr>
<tr class="separator:a74ee88bc6983d2e957294e50e020d3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c0de3ea703bc39e7861e433235c61c" id="r_af5c0de3ea703bc39e7861e433235c61c"><td class="memTemplParams" colspan="2"><a id="af5c0de3ea703bc39e7861e433235c61c" name="af5c0de3ea703bc39e7861e433235c61c"></a>
template&lt;typename FuncType&gt; <br />
requires std::convertible_to&lt;FuncType, std::function&lt;void()&gt;&gt;</td></tr>
<tr class="memitem:af5c0de3ea703bc39e7861e433235c61c"><td class="memTemplItemLeft" align="right" valign="top">ace void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>if_lane</b> (FuncType true_branch)</td></tr>
<tr class="separator:af5c0de3ea703bc39e7861e433235c61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe507572b3f75b60ca9c3f5ecb75e96d" id="r_afe507572b3f75b60ca9c3f5ecb75e96d"><td class="memTemplParams" colspan="2"><a id="afe507572b3f75b60ca9c3f5ecb75e96d" name="afe507572b3f75b60ca9c3f5ecb75e96d"></a>
template&lt;typename FuncType&gt; <br />
requires std::convertible_to&lt;FuncType, std::function&lt;void()&gt;&gt;</td></tr>
<tr class="memitem:afe507572b3f75b60ca9c3f5ecb75e96d"><td class="memTemplItemLeft" align="right" valign="top">ace void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>if_else_lane</b> (FuncType true_branch, FuncType false_branch)</td></tr>
<tr class="separator:afe507572b3f75b60ca9c3f5ecb75e96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c673083cf761fd409b29db9a12e118c" id="r_a6c673083cf761fd409b29db9a12e118c"><td class="memTemplParams" colspan="2"><a id="a6c673083cf761fd409b29db9a12e118c" name="a6c673083cf761fd409b29db9a12e118c"></a>
template&lt;typename FuncType&gt; <br />
requires std::convertible_to&lt;FuncType, std::function&lt;void(int)&gt;&gt;</td></tr>
<tr class="memitem:a6c673083cf761fd409b29db9a12e118c"><td class="memTemplItemLeft" align="right" valign="top">ace void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>if_lane_with_index</b> (FuncType true_branch)</td></tr>
<tr class="separator:a6c673083cf761fd409b29db9a12e118c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6958b76348d1d3fbc9725b07efcfc7c" id="r_ab6958b76348d1d3fbc9725b07efcfc7c"><td class="memTemplParams" colspan="2"><a id="ab6958b76348d1d3fbc9725b07efcfc7c" name="ab6958b76348d1d3fbc9725b07efcfc7c"></a>
template&lt;typename FuncType1, typename FuncType2&gt; <br />
requires std::convertible_to&lt;FuncType1, std::function&lt;void(int)&gt;&gt; &amp;&amp; std::convertible_to&lt;FuncType2, std::function&lt;void(int)&gt;&gt;</td></tr>
<tr class="memitem:ab6958b76348d1d3fbc9725b07efcfc7c"><td class="memTemplItemLeft" align="right" valign="top">ace void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>if_else_lane_with_index</b> (FuncType1 true_branch, FuncType2 false_branch)</td></tr>
<tr class="separator:ab6958b76348d1d3fbc9725b07efcfc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6330b80d6fa33ffa48d4ec1ff165df47" id="r_a6330b80d6fa33ffa48d4ec1ff165df47"><td class="memItemLeft" align="right" valign="top"><a id="a6330b80d6fa33ffa48d4ec1ff165df47" name="a6330b80d6fa33ffa48d4ec1ff165df47"></a>
ace bool&#160;</td><td class="memItemRight" valign="bottom"><b>any</b> ()</td></tr>
<tr class="separator:a6330b80d6fa33ffa48d4ec1ff165df47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f5d41b1f5b087e0f831bf3fe012a05" id="r_ae0f5d41b1f5b087e0f831bf3fe012a05"><td class="memItemLeft" align="right" valign="top"><a id="ae0f5d41b1f5b087e0f831bf3fe012a05" name="ae0f5d41b1f5b087e0f831bf3fe012a05"></a>
ace bool&#160;</td><td class="memItemRight" valign="bottom"><b>all</b> ()</td></tr>
<tr class="separator:ae0f5d41b1f5b087e0f831bf3fe012a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705d58fd1093bf6df4cd3dc825baaaad" id="r_a705d58fd1093bf6df4cd3dc825baaaad"><td class="memTemplParams" colspan="2"><a id="a705d58fd1093bf6df4cd3dc825baaaad" name="a705d58fd1093bf6df4cd3dc825baaaad"></a>
template&lt;std::size_t Index&gt; </td></tr>
<tr class="memitem:a705d58fd1093bf6df4cd3dc825baaaad"><td class="memTemplItemLeft" align="right" valign="top">std::tuple_element_t&lt; Index, <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> ()</td></tr>
<tr class="separator:a705d58fd1093bf6df4cd3dc825baaaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9b39610ee7243ea7499711aeb821de0e" id="r_a9b39610ee7243ea7499711aeb821de0e"><td class="memItemLeft" align="right" valign="top">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b39610ee7243ea7499711aeb821de0e">LoadScalar</a> (const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *ptr)</td></tr>
<tr class="memdesc:a9b39610ee7243ea7499711aeb821de0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a scalar pointer.  <br /></td></tr>
<tr class="separator:a9b39610ee7243ea7499711aeb821de0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15035cf16b0f53849ed5020b6113b9f3" id="r_a15035cf16b0f53849ed5020b6113b9f3"><td class="memItemLeft" align="right" valign="top">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15035cf16b0f53849ed5020b6113b9f3">FromScalar</a> (<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> scalar)</td></tr>
<tr class="memdesc:a15035cf16b0f53849ed5020b6113b9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a scalar value.  <br /></td></tr>
<tr class="separator:a15035cf16b0f53849ed5020b6113b9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5565fae6a0b1de3eb06f0353cc76dc16" id="r_a5565fae6a0b1de3eb06f0353cc76dc16"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptsimd_1_1is__vector__type.html">simd::is_vector_type</a> IntrinsicType&gt; </td></tr>
<tr class="memitem:a5565fae6a0b1de3eb06f0353cc76dc16"><td class="memTemplItemLeft" align="right" valign="top">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5565fae6a0b1de3eb06f0353cc76dc16">FromLane</a> (<a class="el" href="classargon_1_1Lane.html">argon::Lane</a>&lt; IntrinsicType &gt; lane)</td></tr>
<tr class="memdesc:a5565fae6a0b1de3eb06f0353cc76dc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a <a class="el" href="classargon_1_1Lane.html" title="Represents a single lane of a SIMD vector.">Lane</a> object.  <br /></td></tr>
<tr class="separator:a5565fae6a0b1de3eb06f0353cc76dc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b2418d570b1d21c86d942f0b04a1fe" id="r_a36b2418d570b1d21c86d942f0b04a1fe"><td class="memTemplParams" colspan="2">template&lt;size_t LaneIndex&gt; </td></tr>
<tr class="memitem:a36b2418d570b1d21c86d942f0b04a1fe"><td class="memTemplItemLeft" align="right" valign="top">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a36b2418d570b1d21c86d942f0b04a1fe">FromLane</a> (<a class="el" href="classargon_1_1ConstLane.html">argon::ConstLane</a>&lt; LaneIndex, VectorType &gt; lane)</td></tr>
<tr class="memdesc:a36b2418d570b1d21c86d942f0b04a1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a <a class="el" href="classargon_1_1ConstLane.html" title="Represents a single lane of a SIMD vector, where the lane&#39;s index is known at compile time.">ConstLane</a> object.  <br /></td></tr>
<tr class="separator:a36b2418d570b1d21c86d942f0b04a1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136fe4f1f1e3bb707a9633ef6dcbbb4d" id="r_a136fe4f1f1e3bb707a9633ef6dcbbb4d"><td class="memItemLeft" align="right" valign="top">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a136fe4f1f1e3bb707a9633ef6dcbbb4d">Iota</a> (<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> start)</td></tr>
<tr class="memdesc:a136fe4f1f1e3bb707a9633ef6dcbbb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from an incrementing sequence.  <br /></td></tr>
<tr class="separator:a136fe4f1f1e3bb707a9633ef6dcbbb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78d5459016bcb9582ef3980046c26a3" id="r_ae78d5459016bcb9582ef3980046c26a3"><td class="memTemplParams" colspan="2">template&lt;typename FuncType&gt; <br />
requires std::convertible_to&lt;FuncType, std::function&lt;<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>()&gt;&gt;</td></tr>
<tr class="memitem:ae78d5459016bcb9582ef3980046c26a3"><td class="memTemplItemLeft" align="right" valign="top">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae78d5459016bcb9582ef3980046c26a3">Generate</a> (FuncType body)</td></tr>
<tr class="memdesc:ae78d5459016bcb9582ef3980046c26a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a function that generates values.  <br /></td></tr>
<tr class="separator:ae78d5459016bcb9582ef3980046c26a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2a2ace770aa8353f2b777edba24c34" id="r_a0c2a2ace770aa8353f2b777edba24c34"><td class="memTemplParams" colspan="2">template&lt;typename FuncType&gt; <br />
requires std::convertible_to&lt;FuncType, std::function&lt;<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>(<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>)&gt;&gt;</td></tr>
<tr class="memitem:a0c2a2ace770aa8353f2b777edba24c34"><td class="memTemplItemLeft" align="right" valign="top">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0c2a2ace770aa8353f2b777edba24c34">GenerateWithIndex</a> (FuncType body)</td></tr>
<tr class="memdesc:a0c2a2ace770aa8353f2b777edba24c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a function that generates values with an index.  <br /></td></tr>
<tr class="separator:a0c2a2ace770aa8353f2b777edba24c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffef5a2a8924eab18f77d73a188ee57" id="r_a1ffef5a2a8924eab18f77d73a188ee57"><td class="memItemLeft" align="right" valign="top"><a id="a1ffef5a2a8924eab18f77d73a188ee57" name="a1ffef5a2a8924eab18f77d73a188ee57"></a>
static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Load</b> (const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *ptr)</td></tr>
<tr class="memdesc:a1ffef5a2a8924eab18f77d73a188ee57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer. <br /></td></tr>
<tr class="separator:a1ffef5a2a8924eab18f77d73a188ee57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07e70d54a8826a406e37430294e1251" id="r_aa07e70d54a8826a406e37430294e1251"><td class="memItemLeft" align="right" valign="top"><a id="aa07e70d54a8826a406e37430294e1251" name="aa07e70d54a8826a406e37430294e1251"></a>
static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LoadCopy</b> (const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *ptr)</td></tr>
<tr class="memdesc:aa07e70d54a8826a406e37430294e1251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer, duplicating the value across all lanes. <br /></td></tr>
<tr class="separator:aa07e70d54a8826a406e37430294e1251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5096e120dbbc2ce26547a0732808db" id="r_a8f5096e120dbbc2ce26547a0732808db"><td class="memItemLeft" align="right" valign="top">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f5096e120dbbc2ce26547a0732808db">LoadGatherOffsetBytes</a> (const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *base, <a class="el" href="namespaceargon_1_1helpers.html#a78d315330017f0fe0a14cccd2d5b318a">helpers::ArgonFor_t</a>&lt; simd::make_unsigned_t&lt; Bool_t&lt; VectorType &gt; &gt; &gt; offset_vector)</td></tr>
<tr class="memdesc:a8f5096e120dbbc2ce26547a0732808db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using a base address and a vector of offset bytes and a base pointer, create a new vector.  <br /></td></tr>
<tr class="separator:a8f5096e120dbbc2ce26547a0732808db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f02804de05da528affcfda49b45b86" id="r_ab9f02804de05da528affcfda49b45b86"><td class="memItemLeft" align="right" valign="top">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9f02804de05da528affcfda49b45b86">LoadGatherOffsetIndex</a> (const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *base, <a class="el" href="namespaceargon_1_1helpers.html#a78d315330017f0fe0a14cccd2d5b318a">helpers::ArgonFor_t</a>&lt; simd::make_unsigned_t&lt; Bool_t&lt; VectorType &gt; &gt; &gt; offset_vector)</td></tr>
<tr class="memdesc:ab9f02804de05da528affcfda49b45b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using a base address and a vector of offset indices and a base pointer, create a new vector.  <br /></td></tr>
<tr class="separator:ab9f02804de05da528affcfda49b45b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111495cbe4a08d7088edf156237f1a0a" id="r_a111495cbe4a08d7088edf156237f1a0a"><td class="memTemplParams" colspan="2">template&lt;size_t stride&gt; </td></tr>
<tr class="memitem:a111495cbe4a08d7088edf156237f1a0a"><td class="memTemplItemLeft" align="right" valign="top">static ace std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, stride &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a111495cbe4a08d7088edf156237f1a0a">LoadInterleaved</a> (const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *ptr)</td></tr>
<tr class="memdesc:a111495cbe4a08d7088edf156237f1a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load multiple vectors from a pointer, de-interleaving.  <br /></td></tr>
<tr class="separator:a111495cbe4a08d7088edf156237f1a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae261783ad09cb429f176bb9fe4ed50" id="r_a8ae261783ad09cb429f176bb9fe4ed50"><td class="memTemplParams" colspan="2">template&lt;size_t stride&gt; </td></tr>
<tr class="memitem:a8ae261783ad09cb429f176bb9fe4ed50"><td class="memTemplItemLeft" align="right" valign="top">static ace std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, stride &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8ae261783ad09cb429f176bb9fe4ed50">LoadCopyInterleaved</a> (const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *ptr)</td></tr>
<tr class="memdesc:a8ae261783ad09cb429f176bb9fe4ed50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load multiple vectors from a pointer, duplicating the value across all lanes.  <br /></td></tr>
<tr class="separator:a8ae261783ad09cb429f176bb9fe4ed50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7aacefb3f566661a545762a9c7a82d3" id="r_ab7aacefb3f566661a545762a9c7a82d3"><td class="memTemplParams" colspan="2">template&lt;size_t LaneIndex, size_t Stride&gt; </td></tr>
<tr class="memitem:ab7aacefb3f566661a545762a9c7a82d3"><td class="memTemplItemLeft" align="right" valign="top">static ace std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, Stride &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7aacefb3f566661a545762a9c7a82d3">LoadToLaneInterleaved</a> (simd::MultiVector_t&lt; VectorType, Stride &gt; multi, const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *ptr)</td></tr>
<tr class="memdesc:ab7aacefb3f566661a545762a9c7a82d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a value from a pointer into a vector at the lane index <code>lane</code>, de-interleaving.  <br /></td></tr>
<tr class="separator:ab7aacefb3f566661a545762a9c7a82d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb92fb0ea18c81713d98cf2ddc9aa8c" id="r_a4cb92fb0ea18c81713d98cf2ddc9aa8c"><td class="memTemplParams" colspan="2">template&lt;size_t lane, size_t stride&gt; </td></tr>
<tr class="memitem:a4cb92fb0ea18c81713d98cf2ddc9aa8c"><td class="memTemplItemLeft" align="right" valign="top">static ace std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, stride &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4cb92fb0ea18c81713d98cf2ddc9aa8c">LoadToLaneInterleaved</a> (std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, stride &gt; multi, const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *ptr)</td></tr>
<tr class="memdesc:a4cb92fb0ea18c81713d98cf2ddc9aa8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a value from a pointer into a vector at the lane index <code>lane</code>, de-interleaving.     <br /></td></tr>
<tr class="separator:a4cb92fb0ea18c81713d98cf2ddc9aa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d59cd840ce89da92612577c9d96306a" id="r_a7d59cd840ce89da92612577c9d96306a"><td class="memTemplParams" colspan="2">template&lt;size_t stride&gt; </td></tr>
<tr class="memitem:a7d59cd840ce89da92612577c9d96306a"><td class="memTemplItemLeft" align="right" valign="top">static ace std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, stride &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7d59cd840ce89da92612577c9d96306a">LoadGatherOffsetIndexInterleaved</a> (const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *base_ptr, <a class="el" href="namespaceargon_1_1helpers.html#a78d315330017f0fe0a14cccd2d5b318a">helpers::ArgonFor_t</a>&lt; simd::make_unsigned_t&lt; Bool_t&lt; VectorType &gt; &gt; &gt; offset_vector)</td></tr>
<tr class="memdesc:a7d59cd840ce89da92612577c9d96306a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a Load-Gather of interleaved elements.  <br /></td></tr>
<tr class="separator:a7d59cd840ce89da92612577c9d96306a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab921d46adcbb7bff17e8d46be72cbe7a" id="r_ab921d46adcbb7bff17e8d46be72cbe7a"><td class="memTemplParams" colspan="2">template&lt;size_t n&gt; </td></tr>
<tr class="memitem:ab921d46adcbb7bff17e8d46be72cbe7a"><td class="memTemplItemLeft" align="right" valign="top">static ace std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab921d46adcbb7bff17e8d46be72cbe7a">LoadMulti</a> (const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *ptr)</td></tr>
<tr class="memdesc:ab921d46adcbb7bff17e8d46be72cbe7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load n vectors from a single contiguous set of memory.  <br /></td></tr>
<tr class="separator:ab921d46adcbb7bff17e8d46be72cbe7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8c5704648ae236177dc1efd6aa72ee" id="r_a8e8c5704648ae236177dc1efd6aa72ee"><td class="memItemLeft" align="right" valign="top"><a id="a8e8c5704648ae236177dc1efd6aa72ee" name="a8e8c5704648ae236177dc1efd6aa72ee"></a>
static ace int&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> ()</td></tr>
<tr class="memdesc:a8e8c5704648ae236177dc1efd6aa72ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements. <br /></td></tr>
<tr class="separator:a8e8c5704648ae236177dc1efd6aa72ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ad92ce1a195a40c1f752ce0ddc524c9e4" id="r_ad92ce1a195a40c1f752ce0ddc524c9e4"><td class="memItemLeft" align="right" valign="top"><a id="ad92ce1a195a40c1f752ce0ddc524c9e4" name="ad92ce1a195a40c1f752ce0ddc524c9e4"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>lanes</b> = (simd::is_quadword_v&lt;VectorType&gt; ? 16 : 8) / sizeof(<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>)</td></tr>
<tr class="memdesc:ad92ce1a195a40c1f752ce0ddc524c9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of lanes in the SIMD vector. <br /></td></tr>
<tr class="separator:ad92ce1a195a40c1f752ce0ddc524c9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a9ec4da597672757bcff496aad7eaf24f" id="r_a9ec4da597672757bcff496aad7eaf24f"><td class="memTemplParams" colspan="2"><a id="a9ec4da597672757bcff496aad7eaf24f" name="a9ec4da597672757bcff496aad7eaf24f"></a>
template&lt;std::size_t... Ints&gt; </td></tr>
<tr class="memitem:a9ec4da597672757bcff496aad7eaf24f"><td class="memTemplItemLeft" align="right" valign="top">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IotaHelper</b> (<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> start, std::index_sequence&lt; Ints... &gt;)</td></tr>
<tr class="separator:a9ec4da597672757bcff496aad7eaf24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aad9a8ab3a682038fad2b27463d04ff34" id="r_aad9a8ab3a682038fad2b27463d04ff34"><td class="memItemLeft" align="right" valign="top"><a id="aad9a8ab3a682038fad2b27463d04ff34" name="aad9a8ab3a682038fad2b27463d04ff34"></a>
VectorType&#160;</td><td class="memItemRight" valign="bottom"><b>vec_</b></td></tr>
<tr class="separator:aad9a8ab3a682038fad2b27463d04ff34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename VectorType&gt;<br />
class argon::Vector&lt; VectorType &gt;</div><p>Represents a SIMD vector with various operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorType</td><td>The type of the SIMD vector. (e.g. int32x4_t, float32x4_t)</td></tr>
  </table>
  </dd>
</dl>
<p>This class provides a wrapper around SIMD vector types, allowing for object-oriented operations on the vector. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a04b817b2f0d97814f2cf418b2a2ceba0" name="a04b817b2f0d97814f2cf418b2a2ceba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b817b2f0d97814f2cf418b2a2ceba0">&#9670;&#160;</a></span>Vector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::Vector </td>
          <td>(</td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>vector</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a SIMD vector type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>The SIMD vector to construct from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c822d6e8b568d4c6f6131fbbfd10982" name="a6c822d6e8b568d4c6f6131fbbfd10982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c822d6e8b568d4c6f6131fbbfd10982">&#9670;&#160;</a></span>Vector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::Vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a></td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value to construct from.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor duplicates the scalar value across all lanes of the SIMD vector. </p>

</div>
</div>
<a id="af4503c9cb6430a57c62888056ae5779c" name="af4503c9cb6430a57c62888056ae5779c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4503c9cb6430a57c62888056ae5779c">&#9670;&#160;</a></span>Vector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::Vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classargon_1_1Lane.html">argon::Lane</a>&lt; VectorType &gt;</td>          <td class="paramname"><span class="paramname"><em>lane</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a <a class="el" href="classargon_1_1Lane.html" title="Represents a single lane of a SIMD vector.">Lane</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lane</td><td>The <a class="el" href="classargon_1_1Lane.html" title="Represents a single lane of a SIMD vector.">Lane</a> object to construct from.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor duplicates the lane value across all lanes of the SIMD vector. </p>

</div>
</div>
<a id="ad0bd8c46fcb61704f5c532bae17bf837" name="ad0bd8c46fcb61704f5c532bae17bf837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0bd8c46fcb61704f5c532bae17bf837">&#9670;&#160;</a></span>Vector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;size_t LaneIndex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::Vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classargon_1_1ConstLane.html">argon::ConstLane</a>&lt; LaneIndex, VectorType &gt;</td>          <td class="paramname"><span class="paramname"><em>lane</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a <a class="el" href="classargon_1_1ConstLane.html" title="Represents a single lane of a SIMD vector, where the lane&#39;s index is known at compile time.">ConstLane</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lane</td><td>The <a class="el" href="classargon_1_1ConstLane.html" title="Represents a single lane of a SIMD vector, where the lane&#39;s index is known at compile time.">ConstLane</a> object to construct from.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor duplicates the lane value across all lanes of the SIMD vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lane</td><td>The <a class="el" href="classargon_1_1ConstLane.html" title="Represents a single lane of a SIMD vector, where the lane&#39;s index is known at compile time.">ConstLane</a> object to construct from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7cebac6fe57dcbc72385ffa4f27c76c1" name="a7cebac6fe57dcbc72385ffa4f27c76c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cebac6fe57dcbc72385ffa4f27c76c1">&#9670;&#160;</a></span>AddHalve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::AddHalve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two vectors, halving the result. </p>
<p>Equivalent to (a + b) / 2. </p>

</div>
</div>
<a id="af5048c4ce50086aa1662e60155ff83e4" name="af5048c4ce50086aa1662e60155ff83e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5048c4ce50086aa1662e60155ff83e4">&#9670;&#160;</a></span>AddHalveRound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::AddHalveRound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two vectors, halving and rounding the result. </p>
<p>Equivalent to round((a + b) / 2). </p>

</div>
</div>
<a id="a36da1a5e6e183e9ec58773f86a730775" name="a36da1a5e6e183e9ec58773f86a730775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36da1a5e6e183e9ec58773f86a730775">&#9670;&#160;</a></span>AddSaturate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::AddSaturate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two vectors, saturating the result. </p>
<p>Equivalent to a + b, but saturates to the maximum value if the result exceeds the maximum representable value. </p>

</div>
</div>
<a id="adf81303d33688352129c9c6c5acbec54" name="adf81303d33688352129c9c6c5acbec54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf81303d33688352129c9c6c5acbec54">&#9670;&#160;</a></span>BitwiseAndNot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::BitwiseAndNot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise AND of the vector with the NOT of another vector. </p>
<p>Equivalent to a &amp; ~b. </p>

</div>
</div>
<a id="ade26621c9a471b9c5ccbde3bcc37db93" name="ade26621c9a471b9c5ccbde3bcc37db93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade26621c9a471b9c5ccbde3bcc37db93">&#9670;&#160;</a></span>BitwiseClear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::BitwiseClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise AND of the vector with the NOT of another vector.    </p>
<p>Equivalent to a &amp; ~b.    </p>

</div>
</div>
<a id="a4fd51e224bfbdc19aed595a95dd9b737" name="a4fd51e224bfbdc19aed595a95dd9b737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd51e224bfbdc19aed595a95dd9b737">&#9670;&#160;</a></span>BitwiseNot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::BitwiseNot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise ops. </p>
<p>Bitwise NOT of the vector </p>

</div>
</div>
<a id="a34329dd0e9f65efb3c85f0c0323ceed9" name="a34329dd0e9f65efb3c85f0c0323ceed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34329dd0e9f65efb3c85f0c0323ceed9">&#9670;&#160;</a></span>BitwiseOrNot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::BitwiseOrNot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise OR of the vector with the NOT of another vector. </p>
<p>Equivalent to a | ~b. </p>

</div>
</div>
<a id="aaf8cf48035785f21276b14acb20fa8ae" name="aaf8cf48035785f21276b14acb20fa8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8cf48035785f21276b14acb20fa8ae">&#9670;&#160;</a></span>BitwiseSelect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;typename ArgType&gt; <br />
requires std::is_unsigned_v&lt;<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::BitwiseSelect </td>
          <td>(</td>
          <td class="paramtype">ArgType</td>          <td class="paramname"><span class="paramname"><em>true_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType</td>          <td class="paramname"><span class="paramname"><em>false_value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise select between two vectors, using the current vector as a mask. </p>
<p>Equivalent to (mask &amp; b) | (~mask &amp; c). </p>

</div>
</div>
<a id="a4bd82746876ae1dce97036fda72bcd33" name="a4bd82746876ae1dce97036fda72bcd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd82746876ae1dce97036fda72bcd33">&#9670;&#160;</a></span>CompareTestNonzero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a88f641dc73c423f906d60554a58e763f">predicate_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::CompareTestNonzero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ands the current vector with the given vector, then checks if nonzero. </p>
<p>If so, fills the lane with all ones</p>
<p>Equivalent to (a &amp; b) != 0 ? 0xFFFFFFFF : 0x00000000 </p>

</div>
</div>
<a id="a4938dd3f55ba817c166bc86278bd5dd6" name="a4938dd3f55ba817c166bc86278bd5dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4938dd3f55ba817c166bc86278bd5dd6">&#9670;&#160;</a></span>CountActiveBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::CountActiveBits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of bits that are set to one in the vector. </p>
<p>Equivalent to std::popcount(a). </p>

</div>
</div>
<a id="a3565b12089d333da836e7ba087834380" name="a3565b12089d333da836e7ba087834380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3565b12089d333da836e7ba087834380">&#9670;&#160;</a></span>CountLeadingSignBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="namespaceargon_1_1helpers.html#a78d315330017f0fe0a14cccd2d5b318a">helpers::ArgonFor_t</a>&lt; simd::make_signed_t&lt; Bool_t&lt; VectorType &gt; &gt; &gt; <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::CountLeadingSignBits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of consecutive bits following the sign bit that are set to the same value as the sign bit. </p>
<p>Equivalent to std::countl_one(a). </p>

</div>
</div>
<a id="ae9d2af44ba36962119d4a23d8b9be3b7" name="ae9d2af44ba36962119d4a23d8b9be3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d2af44ba36962119d4a23d8b9be3b7">&#9670;&#160;</a></span>CountLeadingZeroBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::CountLeadingZeroBits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of consecutive top bits that are set to zero. </p>
<p>Equivalent to std::countl_zero(a) </p>

</div>
</div>
<a id="a3decc478c1472bc120da30c8cbd349b0" name="a3decc478c1472bc120da30c8cbd349b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3decc478c1472bc120da30c8cbd349b0">&#9670;&#160;</a></span>Equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#abb337d1f5ce5ced64b5a234b8ee9ee05">argon_bool_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::Equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the lanes of two vectors, setting the result lane's bits to ON if are equal. </p>
<p>Equivalent to a == b ? 0xFFFFFFFF : 0x00000000 </p>

</div>
</div>
<a id="a190a0c3091b13281aabf213875a5ee69" name="a190a0c3091b13281aabf213875a5ee69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190a0c3091b13281aabf213875a5ee69">&#9670;&#160;</a></span>Extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::Extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract n elements from the lower end of the operand, and the remaining elements from the top end of this vector, combining them into the result vector. </p>
<p>For example: {a0, a1, a2, a3} and {b0, b1, b2, b3} with n = 1 will result in {b0, a1, a2, a3} </p>

</div>
</div>
<a id="a36b2418d570b1d21c86d942f0b04a1fe" name="a36b2418d570b1d21c86d942f0b04a1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b2418d570b1d21c86d942f0b04a1fe">&#9670;&#160;</a></span>FromLane() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;size_t LaneIndex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::FromLane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classargon_1_1ConstLane.html">argon::ConstLane</a>&lt; LaneIndex, VectorType &gt;</td>          <td class="paramname"><span class="paramname"><em>lane</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a <a class="el" href="classargon_1_1ConstLane.html" title="Represents a single lane of a SIMD vector, where the lane&#39;s index is known at compile time.">ConstLane</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lane</td><td>The <a class="el" href="classargon_1_1ConstLane.html" title="Represents a single lane of a SIMD vector, where the lane&#39;s index is known at compile time.">ConstLane</a> object to construct from.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor duplicates the lane value across all lanes of the SIMD vector. </p><dl class="section return"><dt>Returns</dt><dd>The constructed SIMD vector. </dd></dl>

</div>
</div>
<a id="a5565fae6a0b1de3eb06f0353cc76dc16" name="a5565fae6a0b1de3eb06f0353cc76dc16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5565fae6a0b1de3eb06f0353cc76dc16">&#9670;&#160;</a></span>FromLane() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="conceptsimd_1_1is__vector__type.html">simd::is_vector_type</a> IntrinsicType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::FromLane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classargon_1_1Lane.html">argon::Lane</a>&lt; IntrinsicType &gt;</td>          <td class="paramname"><span class="paramname"><em>lane</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a <a class="el" href="classargon_1_1Lane.html" title="Represents a single lane of a SIMD vector.">Lane</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lane</td><td>The <a class="el" href="classargon_1_1Lane.html" title="Represents a single lane of a SIMD vector.">Lane</a> object to construct from.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor duplicates the lane value across all lanes of the SIMD vector. </p><dl class="section return"><dt>Returns</dt><dd>The constructed SIMD vector. </dd></dl>

</div>
</div>
<a id="a15035cf16b0f53849ed5020b6113b9f3" name="a15035cf16b0f53849ed5020b6113b9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15035cf16b0f53849ed5020b6113b9f3">&#9670;&#160;</a></span>FromScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::FromScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a></td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value to construct from.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor duplicates the scalar value across all lanes of the SIMD vector. </p><dl class="section return"><dt>Returns</dt><dd>The constructed SIMD vector. </dd></dl>

</div>
</div>
<a id="ae78d5459016bcb9582ef3980046c26a3" name="ae78d5459016bcb9582ef3980046c26a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78d5459016bcb9582ef3980046c26a3">&#9670;&#160;</a></span>Generate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;typename FuncType&gt; <br />
requires std::convertible_to&lt;FuncType, std::function&lt;<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>()&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::Generate </td>
          <td>(</td>
          <td class="paramtype">FuncType</td>          <td class="paramname"><span class="paramname"><em>body</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a function that generates values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>The function that generates the values.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor creates a SIMD vector with lanes containing values generated by the function. </p><dl class="section return"><dt>Returns</dt><dd>The constructed SIMD vector. </dd></dl>

</div>
</div>
<a id="a0c2a2ace770aa8353f2b777edba24c34" name="a0c2a2ace770aa8353f2b777edba24c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2a2ace770aa8353f2b777edba24c34">&#9670;&#160;</a></span>GenerateWithIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;typename FuncType&gt; <br />
requires std::convertible_to&lt;FuncType, std::function&lt;<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>(<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>)&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::GenerateWithIndex </td>
          <td>(</td>
          <td class="paramtype">FuncType</td>          <td class="paramname"><span class="paramname"><em>body</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a function that generates values with an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>The function that generates the values.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor creates a SIMD vector with lanes containing values generated by the function using the index. </p><dl class="section return"><dt>Returns</dt><dd>The constructed SIMD vector. </dd></dl>

</div>
</div>
<a id="aca0e82bb381963cb4a43c3c54762484b" name="aca0e82bb381963cb4a43c3c54762484b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0e82bb381963cb4a43c3c54762484b">&#9670;&#160;</a></span>GetLane() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;size_t LaneIndex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace const <a class="el" href="#a42b8f34739c804799a601bdeabedc7ec">const_lane_type</a>&lt; LaneIndex &gt; <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::GetLane </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a single lane of the vector by index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LaneIndex</td><td>The index of the lane to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the specified lane in the SIMD vector. </dd></dl>

</div>
</div>
<a id="ae37a5488e8811817d2909772b1ff8ca6" name="ae37a5488e8811817d2909772b1ff8ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37a5488e8811817d2909772b1ff8ca6">&#9670;&#160;</a></span>GetLane() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace const <a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::GetLane </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a single lane of the vector by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the lane to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the specified lane in the SIMD vector. </dd></dl>

</div>
</div>
<a id="a5c03e6716e222b5d7bca11379c551a48" name="a5c03e6716e222b5d7bca11379c551a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c03e6716e222b5d7bca11379c551a48">&#9670;&#160;</a></span>GetLane() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace const <a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::GetLane </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a single lane of the vector by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the lane to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the specified lane in the SIMD vector. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you know the index of the lane at compile time, you should use GetLane&lt;LaneIndex&gt;() instead. </dd></dl>

</div>
</div>
<a id="a919a7820afce4ddf71dcd8afc11db36b" name="a919a7820afce4ddf71dcd8afc11db36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919a7820afce4ddf71dcd8afc11db36b">&#9670;&#160;</a></span>GreaterThan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#abb337d1f5ce5ced64b5a234b8ee9ee05">argon_bool_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::GreaterThan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the lanes of two vectors, setting the result lane's bits to ON if a is greater than b. </p>
<p>Equivalent to a &gt; b ? 0xFFFFFFFF : 0x00000000 </p>

</div>
</div>
<a id="a7b12a632fc5646f7ed4751d07b28b13c" name="a7b12a632fc5646f7ed4751d07b28b13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b12a632fc5646f7ed4751d07b28b13c">&#9670;&#160;</a></span>GreaterThanOrEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#abb337d1f5ce5ced64b5a234b8ee9ee05">argon_bool_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::GreaterThanOrEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the lanes of two vectors, setting the result lane's bits to ON if a is greater than or equal to b. </p>
<p>Equivalent to a &gt;= b ? 0xFFFFFFFF : 0x00000000 </p>

</div>
</div>
<a id="a136fe4f1f1e3bb707a9633ef6dcbbb4d" name="a136fe4f1f1e3bb707a9633ef6dcbbb4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136fe4f1f1e3bb707a9633ef6dcbbb4d">&#9670;&#160;</a></span>Iota()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::Iota </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a></td>          <td class="paramname"><span class="paramname"><em>start</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from an incrementing sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting value of the sequence. </td></tr>
    <tr><td class="paramname">step</td><td>The step size of the sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed SIMD vector.</dd></dl>
<p>This constructor creates a SIMD vector with lanes containing values from start to start + (lanes - 1) * step. </p>

</div>
</div>
<a id="a66b11498ebe5371b468f10c76091e9f1" name="a66b11498ebe5371b468f10c76091e9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b11498ebe5371b468f10c76091e9f1">&#9670;&#160;</a></span>LessThan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#abb337d1f5ce5ced64b5a234b8ee9ee05">argon_bool_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::LessThan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the lanes of two vectors, setting the result lane's bits to ON if a is less than b. </p>
<p>Equivalent to a &lt; b ? 0xFFFFFFFF : 0x00000000 </p>

</div>
</div>
<a id="a1c34bfe1567cedd121d6945031ff8687" name="a1c34bfe1567cedd121d6945031ff8687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c34bfe1567cedd121d6945031ff8687">&#9670;&#160;</a></span>LessThanOrEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#abb337d1f5ce5ced64b5a234b8ee9ee05">argon_bool_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::LessThanOrEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the lanes of two vectors, setting the result lane's bits to ON if a is less than or equal to b. </p>
<p>Equivalent to a &lt;= b ? 0xFFFFFFFF : 0x00000000 </p>

</div>
</div>
<a id="a8ae261783ad09cb429f176bb9fe4ed50" name="a8ae261783ad09cb429f176bb9fe4ed50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae261783ad09cb429f176bb9fe4ed50">&#9670;&#160;</a></span>LoadCopyInterleaved()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;size_t stride&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ace std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, stride &gt; <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::LoadCopyInterleaved </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load multiple vectors from a pointer, duplicating the value across all lanes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stride</td><td>The interleave stride </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to load from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new multi-vector Example: {r0, g0, b0, r1, g1, b1} will become {{r0, r0}, {g0, g0}, {b0, b0}} </dd></dl>

</div>
</div>
<a id="a8f5096e120dbbc2ce26547a0732808db" name="a8f5096e120dbbc2ce26547a0732808db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5096e120dbbc2ce26547a0732808db">&#9670;&#160;</a></span>LoadGatherOffsetBytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::LoadGatherOffsetBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *</td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceargon_1_1helpers.html#a78d315330017f0fe0a14cccd2d5b318a">helpers::ArgonFor_t</a>&lt; simd::make_unsigned_t&lt; Bool_t&lt; VectorType &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>offset_vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Using a base address and a vector of offset bytes and a base pointer, create a new vector. </p>
<dl class="section note"><dt>Note</dt><dd>On NEON this incurs a writeback + load penalty </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The address to index from </td></tr>
    <tr><td class="paramname">offset_vector</td><td>A vector of offset indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector constructed from the various indices </dd></dl>

</div>
</div>
<a id="ab9f02804de05da528affcfda49b45b86" name="ab9f02804de05da528affcfda49b45b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f02804de05da528affcfda49b45b86">&#9670;&#160;</a></span>LoadGatherOffsetIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::LoadGatherOffsetIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *</td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceargon_1_1helpers.html#a78d315330017f0fe0a14cccd2d5b318a">helpers::ArgonFor_t</a>&lt; simd::make_unsigned_t&lt; Bool_t&lt; VectorType &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>offset_vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Using a base address and a vector of offset indices and a base pointer, create a new vector. </p>
<dl class="section note"><dt>Note</dt><dd>On NEON this incurs a writeback + load penalty </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The address to index from </td></tr>
    <tr><td class="paramname">offset_vector</td><td>A vector of offset indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector constructed from the various indices </dd></dl>

</div>
</div>
<a id="a7d59cd840ce89da92612577c9d96306a" name="a7d59cd840ce89da92612577c9d96306a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d59cd840ce89da92612577c9d96306a">&#9670;&#160;</a></span>LoadGatherOffsetIndexInterleaved()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;size_t stride&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ace std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, stride &gt; <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::LoadGatherOffsetIndexInterleaved </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *</td>          <td class="paramname"><span class="paramname"><em>base_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceargon_1_1helpers.html#a78d315330017f0fe0a14cccd2d5b318a">helpers::ArgonFor_t</a>&lt; simd::make_unsigned_t&lt; Bool_t&lt; VectorType &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>offset_vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a Load-Gather of interleaved elements. </p>
<dl class="section note"><dt>Note</dt><dd>On NEON this incurs a writeback + load penalty</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stride</td><td>the distance between similar elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_ptr</td><td>the address to use as a base for the gather operation </td></tr>
    <tr><td class="paramname">offset_vector</td><td>a vector of offset values that are added to base_ptr to get the address to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::array&lt;argon_type, stride&gt; An array of vectors from the resulting interleaved loads </dd></dl>

</div>
</div>
<a id="a111495cbe4a08d7088edf156237f1a0a" name="a111495cbe4a08d7088edf156237f1a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111495cbe4a08d7088edf156237f1a0a">&#9670;&#160;</a></span>LoadInterleaved()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;size_t stride&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ace std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, stride &gt; <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::LoadInterleaved </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load multiple vectors from a pointer, de-interleaving. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">stride</td><td>The interleave stride </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to load from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new multi-vector This is useful for multi-channel audio or RGB image data. For example: {r0, g0, b0, r1, g1, b1} will become {{r0, r1}, {g0, g1}, {b0, b1}} </dd></dl>

</div>
</div>
<a id="ab921d46adcbb7bff17e8d46be72cbe7a" name="ab921d46adcbb7bff17e8d46be72cbe7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab921d46adcbb7bff17e8d46be72cbe7a">&#9670;&#160;</a></span>LoadMulti()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ace std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, n &gt; <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::LoadMulti </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load n vectors from a single contiguous set of memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>The number of vectors to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to the location in memory to load from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::array An array of NEON vectors. </dd></dl>

</div>
</div>
<a id="a9b39610ee7243ea7499711aeb821de0e" name="a9b39610ee7243ea7499711aeb821de0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b39610ee7243ea7499711aeb821de0e">&#9670;&#160;</a></span>LoadScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::LoadScalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classargon_1_1Vector.html" title="Represents a SIMD vector with various operations.">Vector</a> from a scalar pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to the scalar value to construct from.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor loads the scalar value from the pointer and duplicates it across all lanes of the SIMD vector. </p><dl class="section return"><dt>Returns</dt><dd>The constructed SIMD vector. </dd></dl>

</div>
</div>
<a id="aa2e16481307865c0d17cbc73784e83a0" name="aa2e16481307865c0d17cbc73784e83a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e16481307865c0d17cbc73784e83a0">&#9670;&#160;</a></span>LoadToLane()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;size_t lane&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::LoadToLane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a lane from a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to load from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new vector </dd></dl>

</div>
</div>
<a id="ab7aacefb3f566661a545762a9c7a82d3" name="ab7aacefb3f566661a545762a9c7a82d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7aacefb3f566661a545762a9c7a82d3">&#9670;&#160;</a></span>LoadToLaneInterleaved() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;size_t LaneIndex, size_t Stride&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ace std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, Stride &gt; <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::LoadToLaneInterleaved </td>
          <td>(</td>
          <td class="paramtype">simd::MultiVector_t&lt; VectorType, Stride &gt;</td>          <td class="paramname"><span class="paramname"><em>multi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a value from a pointer into a vector at the lane index <code>lane</code>, de-interleaving. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">lane</td><td>The lane to load </td></tr>
    <tr><td class="paramname">stride</td><td>The interleave stride </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multi</td><td>The multi-vector to load into </td></tr>
    <tr><td class="paramname">ptr</td><td>The pointer to load from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new multi-vector </dd></dl>

</div>
</div>
<a id="a4cb92fb0ea18c81713d98cf2ddc9aa8c" name="a4cb92fb0ea18c81713d98cf2ddc9aa8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb92fb0ea18c81713d98cf2ddc9aa8c">&#9670;&#160;</a></span>LoadToLaneInterleaved() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;size_t lane, size_t stride&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ace std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, stride &gt; <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::LoadToLaneInterleaved </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, stride &gt;</td>          <td class="paramname"><span class="paramname"><em>multi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a value from a pointer into a vector at the lane index <code>lane</code>, de-interleaving.    </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">lane</td><td>The lane to load </td></tr>
    <tr><td class="paramname">stride</td><td>The interleave stride </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multi</td><td>The multi-vector to load into </td></tr>
    <tr><td class="paramname">ptr</td><td>The pointer to load from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new multi-vector    </dd></dl>

</div>
</div>
<a id="a51663230ed752a2cff604c1d380a547f" name="a51663230ed752a2cff604c1d380a547f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51663230ed752a2cff604c1d380a547f">&#9670;&#160;</a></span>Max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::Max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the lanes of two vectors, copying the larger of each lane to the result. </p>
<p>Equivalent to a &gt; b ? a : b </p>

</div>
</div>
<a id="ae9fded6d76878d39a236435acccb3eeb" name="ae9fded6d76878d39a236435acccb3eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fded6d76878d39a236435acccb3eeb">&#9670;&#160;</a></span>Min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::Min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the lanes of two vectors, copying the smaller of each lane to the result. </p>
<p>Equivalent to a &lt; b ? a : b </p>

</div>
</div>
<a id="a083eb76b876a725e5c3f17c3154309f1" name="a083eb76b876a725e5c3f17c3154309f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083eb76b876a725e5c3f17c3154309f1">&#9670;&#160;</a></span>Modulo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::Modulo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the modulo of two vectors. </p>
<p>Equivalent to a % b. </p>

</div>
</div>
<a id="a6632c9d68aa2e4a4049b5011549e8199" name="a6632c9d68aa2e4a4049b5011549e8199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6632c9d68aa2e4a4049b5011549e8199">&#9670;&#160;</a></span>Modulo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::Modulo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the modulo of a vector and a scalar value. </p>
<p>Equivalent to a % b. </p>

</div>
</div>
<a id="a30eb1bff5f1953844facf92590d1d5ed" name="a30eb1bff5f1953844facf92590d1d5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30eb1bff5f1953844facf92590d1d5ed">&#9670;&#160;</a></span>MultiplyAdd() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplyAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two vectors and add a third vector. </p>
<p>Equivalent to a + (b * c). </p>

</div>
</div>
<a id="a5f3fe437a4fc1527fcd9037dc842551a" name="a5f3fe437a4fc1527fcd9037dc842551a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3fe437a4fc1527fcd9037dc842551a">&#9670;&#160;</a></span>MultiplyAdd() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;size_t LaneIndex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplyAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a42b8f34739c804799a601bdeabedc7ec">const_lane_type</a>&lt; LaneIndex &gt;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a vector by a lane value and add a third vector. </p>
<p>Equivalent to a + (b * c). </p>

</div>
</div>
<a id="a2c1e4ae65dd295566c22882412d9f047" name="a2c1e4ae65dd295566c22882412d9f047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1e4ae65dd295566c22882412d9f047">&#9670;&#160;</a></span>MultiplyAdd() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplyAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a vector by a lane value and add a third vector. </p>
<p>Equivalent to a + (b * c). </p>

</div>
</div>
<a id="ac4151310ed078d80405b9ab9787fc987" name="ac4151310ed078d80405b9ab9787fc987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4151310ed078d80405b9ab9787fc987">&#9670;&#160;</a></span>MultiplyAdd() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplyAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a vector by a scalar value and add a third vector. </p>
<p>Equivalent to a + (b * c). </p>

</div>
</div>
<a id="a778eabd1a2014cce0a3dee20e038d44b" name="a778eabd1a2014cce0a3dee20e038d44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778eabd1a2014cce0a3dee20e038d44b">&#9670;&#160;</a></span>MultiplyAdd() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;size_t LaneIndex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplyAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a42b8f34739c804799a601bdeabedc7ec">const_lane_type</a>&lt; LaneIndex &gt;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a vector by a lane value and add a third vector. </p>
<p>Equivalent to a + (b * c). </p>

</div>
</div>
<a id="aec7c5717ca19532b50c9139d26d0d649" name="aec7c5717ca19532b50c9139d26d0d649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7c5717ca19532b50c9139d26d0d649">&#9670;&#160;</a></span>MultiplyAdd() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplyAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a vector by a lane value and add a third vector. </p>
<p>Equivalent to a + (b * c). </p>

</div>
</div>
<a id="a2910bb5d1aed95652f6df336f2184142" name="a2910bb5d1aed95652f6df336f2184142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2910bb5d1aed95652f6df336f2184142">&#9670;&#160;</a></span>MultiplyAdd() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplyAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a vector by a scalar value and add a third vector. </p>
<p>Equivalent to a + (b * c). </p>

</div>
</div>
<a id="a7f7a52e529b6894c26527f5a8ccbca20" name="a7f7a52e529b6894c26527f5a8ccbca20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7a52e529b6894c26527f5a8ccbca20">&#9670;&#160;</a></span>MultiplyAddQMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;typename arg_type&gt; <br />
requires (is_one_of&lt;arg_type, <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>, <a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a>&gt; || std::is_convertible_v&lt;arg_type, <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&gt; || std::is_convertible_v&lt;arg_type, <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplyAddQMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arg_type</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply-add three fixed-point vectors, returning a fixed-point sum. </p>
<p>This is equivalent to a + ((b * c) &gt;&gt; 31) </p>

</div>
</div>
<a id="a318aca048c171533be145f994736dfd8" name="a318aca048c171533be145f994736dfd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318aca048c171533be145f994736dfd8">&#9670;&#160;</a></span>MultiplyQMax() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplyQMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two QMax fixed-point vectors, returning a fixed-point product. </p>
<p>This is equivalent to ((uint64_t)a * b) &gt;&gt; 31 </p>

</div>
</div>
<a id="ae209b4ccfdca4ddd68ec1dad3d8992ab" name="ae209b4ccfdca4ddd68ec1dad3d8992ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae209b4ccfdca4ddd68ec1dad3d8992ab">&#9670;&#160;</a></span>MultiplyQMax() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplyQMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a></td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a QMax fixed-point vector by a lane value, returning a fixed-point product. </p>
<p>This is equivalent to ((uint64_t)a * b) &gt;&gt; 31 </p>

</div>
</div>
<a id="ae9971d8dd8b00595462f04f05658282f" name="ae9971d8dd8b00595462f04f05658282f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9971d8dd8b00595462f04f05658282f">&#9670;&#160;</a></span>MultiplyQMax() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplyQMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a QMax fixed-point vector by a scalar value, returning a fixed-point product. </p>
<p>This is equivalent to ((uint64_t)a * b) &gt;&gt; 31 </p>

</div>
</div>
<a id="a45f0a102c8dd8cc82acd9710ddc15cd1" name="a45f0a102c8dd8cc82acd9710ddc15cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f0a102c8dd8cc82acd9710ddc15cd1">&#9670;&#160;</a></span>MultiplyRoundAddQMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;typename arg_type&gt; <br />
requires (is_one_of&lt;arg_type, <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>, <a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a>&gt; || std::is_convertible_v&lt;arg_type, <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>&gt; || std::is_convertible_v&lt;arg_type, <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplyRoundAddQMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arg_type</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply-round-add three fixed-point vectors, returning a fixed-point sum. </p>
<p>This is equivalent to a + (rnd(b * c) &gt;&gt; 31) </p>

</div>
</div>
<a id="a16e19b56008531293076027a9b9b8153" name="a16e19b56008531293076027a9b9b8153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e19b56008531293076027a9b9b8153">&#9670;&#160;</a></span>MultiplyRoundQMax() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplyRoundQMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two fixed-point vectors, returning a fixed-point product. </p>
<p>This is equivalent to round(a * b) &gt;&gt; 31 </p>

</div>
</div>
<a id="a24bf1284aba99676b4ea555b0ba65ea9" name="a24bf1284aba99676b4ea555b0ba65ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bf1284aba99676b4ea555b0ba65ea9">&#9670;&#160;</a></span>MultiplyRoundQMax() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplyRoundQMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a></td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a fixed-point vector by a lane value, returning a fixed-point product. </p>
<p>This is equivalent to round(a * b) &gt;&gt; 31 </p>

</div>
</div>
<a id="ac30cea740a1b206d0027eeb8c8248621" name="ac30cea740a1b206d0027eeb8c8248621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30cea740a1b206d0027eeb8c8248621">&#9670;&#160;</a></span>MultiplyRoundQMax() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplyRoundQMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a fixed-point vector by a scalar value, returning a fixed-point product. </p>
<p>This is equivalent to round(a * b) &gt;&gt; 31 </p>

</div>
</div>
<a id="a18f15cb6e2ba71f90ac0927bece0250c" name="a18f15cb6e2ba71f90ac0927bece0250c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f15cb6e2ba71f90ac0927bece0250c">&#9670;&#160;</a></span>MultiplySubtract() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplySubtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two vectors and subtract from a third vector. </p>
<p>Equivalent to a - (b * c). </p>

</div>
</div>
<a id="a044130cfb0e6b776a94989d5e33a5e3b" name="a044130cfb0e6b776a94989d5e33a5e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044130cfb0e6b776a94989d5e33a5e3b">&#9670;&#160;</a></span>MultiplySubtract() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplySubtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a03dd715936783524ec28dc59365db01f">lane_type</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a vector by a lane value and subtract from a third vector. </p>
<p>Equivalent to a - (b * c). </p>

</div>
</div>
<a id="a75462f482302303584296d30a5f1b36a" name="a75462f482302303584296d30a5f1b36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75462f482302303584296d30a5f1b36a">&#9670;&#160;</a></span>MultiplySubtract() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplySubtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a vector by a scalar value and subtract from a third vector. </p>
<p>Equivalent to a - (b * c). </p>

</div>
</div>
<a id="aaa89c23ca17233b39740179621e16201" name="aaa89c23ca17233b39740179621e16201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa89c23ca17233b39740179621e16201">&#9670;&#160;</a></span>MultiplySubtract() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::MultiplySubtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a vector by a scalar value and subtract from a third vector. </p>
<p>Equivalent to a - (b * c). </p>

</div>
</div>
<a id="a2775284e15105fd173cace27e941b41b" name="a2775284e15105fd173cace27e941b41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2775284e15105fd173cace27e941b41b">&#9670;&#160;</a></span>PairwiseAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::PairwiseAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pairwise ops. </p>
<p>Pairwise add two vectors, returning the sum of each pair of lanes.</p>
<p>Given a pair of vector {a0, a1, a2, a3} and {b0, b1, b2, b3}, the result is {a0 + a1, a1 + a2, b0 + b1, b1 + b2} </p>

</div>
</div>
<a id="a4e6375e9154485e6930fcc97fe052cc2" name="a4e6375e9154485e6930fcc97fe052cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6375e9154485e6930fcc97fe052cc2">&#9670;&#160;</a></span>PairwiseMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::PairwiseMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select the maximum of each pair of lanes in the two vectors. </p>
<p>Given a pair of vector {a0, a1, a2, a3} and {b0, b1, b2, b3}, the result is {max(a0, a1), max(a2, b2), max(b0, b1), max(b2, b3)} </p>

</div>
</div>
<a id="a02104df04e935b50cb70a2484c12f2d2" name="a02104df04e935b50cb70a2484c12f2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02104df04e935b50cb70a2484c12f2d2">&#9670;&#160;</a></span>PairwiseMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::PairwiseMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select the maximum of each pair of lanes in the two vectors. </p>
<p>Given a pair of vector {a0, a1, a2, a3} and {b0, b1, b2, b3}, the result is {max(a0, a1), max(a2, b2), max(b0, b1), max(b2, b3)} </p>

</div>
</div>
<a id="a6651697b922476d1c5e89234d662e83c" name="a6651697b922476d1c5e89234d662e83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6651697b922476d1c5e89234d662e83c">&#9670;&#160;</a></span>Popcount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::Popcount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of bits that are set to one in the vector.    </p>
<p>Equivalent to std::popcount(a).    </p>

</div>
</div>
<a id="a1b4ad8617da38f5e4a9b9094ede736b5" name="a1b4ad8617da38f5e4a9b9094ede736b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4ad8617da38f5e4a9b9094ede736b5">&#9670;&#160;</a></span>ReciprocalEstimate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::ReciprocalEstimate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1 / value, using an estimate for speed </p>
<dl class="section note"><dt>Note</dt><dd>This is not a precise reciprocal, but it is fast and useful for many applications </dd></dl>

</div>
</div>
<a id="ad88e29f9051bfa88b952f58528e2489c" name="ad88e29f9051bfa88b952f58528e2489c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88e29f9051bfa88b952f58528e2489c">&#9670;&#160;</a></span>Select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;typename ArgType&gt; <br />
requires std::is_unsigned_v&lt;<a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::Select </td>
          <td>(</td>
          <td class="paramtype">ArgType</td>          <td class="paramname"><span class="paramname"><em>true_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType</td>          <td class="paramname"><span class="paramname"><em>false_value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise select between two vectors, using the current vector as a mask.    </p>
<p>Equivalent to (mask &amp; b) | (~mask &amp; c).    </p>

</div>
</div>
<a id="aa519dbdec10abee1979bfa0dd01c18d6" name="aa519dbdec10abee1979bfa0dd01c18d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa519dbdec10abee1979bfa0dd01c18d6">&#9670;&#160;</a></span>ShiftLeft() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::ShiftLeft </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift the elements of the vector to the left by a specified number of bits. </p>
<p>Equivalent to a &lt;&lt; b. </p>

</div>
</div>
<a id="a235f1983552e5049a465dbce9301f0b1" name="a235f1983552e5049a465dbce9301f0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235f1983552e5049a465dbce9301f0b1">&#9670;&#160;</a></span>ShiftLeft() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::ShiftLeft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceargon_1_1helpers.html#a78d315330017f0fe0a14cccd2d5b318a">helpers::ArgonFor_t</a>&lt; simd::make_signed_t&lt; Bool_t&lt; VectorType &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift the elemnets of the vector to the left by a specified number of bits. </p>
<p>Equivalent to a &lt;&lt; b. </p>

</div>
</div>
<a id="a339ac134c3ae1143e6a7244e5bd490ff" name="a339ac134c3ae1143e6a7244e5bd490ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339ac134c3ae1143e6a7244e5bd490ff">&#9670;&#160;</a></span>ShiftLeft() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::ShiftLeft </td>
          <td>(</td>
          <td class="paramtype">std::make_signed_t&lt; simd::Scalar_t&lt; Bool_t&lt; VectorType &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift the elements of the vector to the left by a specified number of bits. </p>
<p>Equivalent to a &lt;&lt; b. </p>

</div>
</div>
<a id="a5a4e1837e5f94e74ef301cbfee9d58bb" name="a5a4e1837e5f94e74ef301cbfee9d58bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4e1837e5f94e74ef301cbfee9d58bb">&#9670;&#160;</a></span>ShiftLeftInsert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::ShiftLeftInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift the elements of the vector to the left by a specified number of bits, and then OR the result with another vector masked to the number of shift bits. </p>
<p>Equivalent to (a &lt;&lt; b) | (c &amp; ((1 &lt;&lt; b) - 1)). </p><dl class="section see"><dt>See also</dt><dd><a href="https://developer.arm.com/documentation/ddi0596/2021-03/SIMD-FP-Instructions/SLI&ndash;Shift-Left-and-Insert&ndash;immediate&ndash;">https://developer.arm.com/documentation/ddi0596/2021-03/SIMD-FP-Instructions/SLI&amp;ndash;Shift-Left-and-Insert&amp;ndash;immediate&amp;ndash;</a> </dd></dl>

</div>
</div>
<a id="adfd871a0354f515c2b91780d1a2aeb8b" name="adfd871a0354f515c2b91780d1a2aeb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd871a0354f515c2b91780d1a2aeb8b">&#9670;&#160;</a></span>ShiftRightAccumulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::ShiftRightAccumulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift the elements of the <code>b</code> vector to the right by a specified number of bits, and then add the result to this vector. </p>
<p>Equivalent to a + (b &gt;&gt; n). </p>

</div>
</div>
<a id="a9c94ab7b62bf793e04388108b643bba7" name="a9c94ab7b62bf793e04388108b643bba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c94ab7b62bf793e04388108b643bba7">&#9670;&#160;</a></span>ShiftRightAccumulateRound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::ShiftRightAccumulateRound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift the elements of the <code>b</code> vector to the right by a specified number of bits, and then add the result to this vector. </p>
<p>Equivalent to a + (b &gt;&gt; n). </p>

</div>
</div>
<a id="aedcff0fce3d0e2568fddb6f0ba115768" name="aedcff0fce3d0e2568fddb6f0ba115768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcff0fce3d0e2568fddb6f0ba115768">&#9670;&#160;</a></span>ShiftRightInsert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::ShiftRightInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift the elements of the vector to the right by a specified number of bits, ORing the result with the vector masked to the number of shift bits. </p>
<p>Equivalent to (a &gt;&gt; b) | (c &amp; ~((1 &lt;&lt; b) - 1)). </p>

</div>
</div>
<a id="a72f5ef376e9294faa4fe36be434a7a50" name="a72f5ef376e9294faa4fe36be434a7a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f5ef376e9294faa4fe36be434a7a50">&#9670;&#160;</a></span>StoreLaneTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<div class="memtemplate">
template&lt;int LaneIndex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace void <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::StoreLaneTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a lane of the vector to a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to store to </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">lane</td><td>The lane to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42451f1aadb8a99656980b90961423da" name="a42451f1aadb8a99656980b90961423da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42451f1aadb8a99656980b90961423da">&#9670;&#160;</a></span>StoreTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace void <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::StoreTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the vector to a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to store to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3bb694741ef42d25f930cb7fce004ac" name="aa3bb694741ef42d25f930cb7fce004ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bb694741ef42d25f930cb7fce004ac">&#9670;&#160;</a></span>SubtractAbs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::SubtractAbs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract two vectors, taking the absolute value of the result. </p>
<p>Equivalent to |a - b|. </p>

</div>
</div>
<a id="aef58f8dc53b5ce13887f3fcd721d7fda" name="aef58f8dc53b5ce13887f3fcd721d7fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef58f8dc53b5ce13887f3fcd721d7fda">&#9670;&#160;</a></span>SubtractAbsAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::SubtractAbsAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract two vectors, taking the absolute value of the result and adding a third vector. </p>
<p>Equivalent to a + |b - c| </p>

</div>
</div>
<a id="aeb396f0fbf479eab31e7ca97a4e88e02" name="aeb396f0fbf479eab31e7ca97a4e88e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb396f0fbf479eab31e7ca97a4e88e02">&#9670;&#160;</a></span>SubtractHalve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::SubtractHalve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract two vectors, halving the result. </p>
<p>Equivalent to (a - b) / 2. </p>

</div>
</div>
<a id="a9fa39b01b6f592232a4b3150f660b8aa" name="a9fa39b01b6f592232a4b3150f660b8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa39b01b6f592232a4b3150f660b8aa">&#9670;&#160;</a></span>TestNonzero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace <a class="el" href="#a88f641dc73c423f906d60554a58e763f">predicate_type</a> <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::TestNonzero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ands the current vector with the given vector, then checks if nonzero.    </p>
<p>If so, fills the lane with all ones</p>
<p>Equivalent to (a &amp; b) != 0 ? 0xFFFFFFFF : 0x00000000    </p>

</div>
</div>
<a id="ad901839710b6027bfc0b3882d1ada7d3" name="ad901839710b6027bfc0b3882d1ada7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad901839710b6027bfc0b3882d1ada7d3">&#9670;&#160;</a></span>to_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace std::array&lt; <a class="el" href="#ac5bd00a35d6eaa0cca199800e44157d9">scalar_type</a>, <a class="el" href="#ad92ce1a195a40c1f752ce0ddc524c9e4">lanes</a> &gt; <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::to_array </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the vector to an array of scalar values. </p>
<dl class="section return"><dt>Returns</dt><dd>An array of scalar values representing the vector. </dd></dl>

</div>
</div>
<a id="a0ea12f326a728a3264306ac6266f4344" name="a0ea12f326a728a3264306ac6266f4344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea12f326a728a3264306ac6266f4344">&#9670;&#160;</a></span>TransposeWith()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, 2 &gt; <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::TransposeWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a 2x2 matrix transpose on two vectors, returning two vectors of pairs. </p>
<p>Given a pair of vectors {{a0, a1, a2, a3}, the result is {{a0, b0, a2, b2}, </p>

</div>
</div>
<a id="a378a84364d98127adb2888a23d260790" name="a378a84364d98127adb2888a23d260790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378a84364d98127adb2888a23d260790">&#9670;&#160;</a></span>UnzipWith()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, 2 &gt; <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::UnzipWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unzip two vectors, returning two vectors of pairs. </p>
<p>Given a pair of vector {a0, b0, a1, b1} and {a2, b2, a3, b3}, the result is {{a0, a1, a2, a3}, {b0, b1, b2, b3}} </p>

</div>
</div>
<a id="a94643eaec4a28cee8492f9bacba8b6eb" name="a94643eaec4a28cee8492f9bacba8b6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94643eaec4a28cee8492f9bacba8b6eb">&#9670;&#160;</a></span>ZipWith()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ace std::array&lt; <a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a>, 2 &gt; <a class="el" href="classargon_1_1Vector.html">argon::Vector</a>&lt; VectorType &gt;::ZipWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9a415e7e729cc854cae3463e41cc3705">argon_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zip two vectors together, returning two vectors of pairs. </p>
<p>Given a pair of vector {a0, a1, a2, a3} and {b0, b1, b2, b3}, the result is {{a0, b0, a1, b1}, {a2, b2, a3, b3}} </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/argon/<a class="el" href="lane_8hpp_source.html">lane.hpp</a></li>
<li>include/argon/<a class="el" href="argon_2vector_8hpp_source.html">vector.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>argon</b></li><li class="navelem"><a class="el" href="classargon_1_1Vector.html">Vector</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
